"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/styler/page",{

/***/ "(app-pages-browser)/./src/utils/documentProcessor.ts":
/*!****************************************!*\
  !*** ./src/utils/documentProcessor.ts ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DocumentProcessor: function() { return /* binding */ DocumentProcessor; }\n/* harmony export */ });\n/* harmony import */ var mammoth__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mammoth */ \"(app-pages-browser)/./node_modules/mammoth/lib/index.js\");\n/* harmony import */ var docx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! docx */ \"(app-pages-browser)/./node_modules/docx/build/index.mjs\");\n/* harmony import */ var jszip__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! jszip */ \"(app-pages-browser)/./node_modules/jszip/dist/jszip.min.js\");\n/* harmony import */ var jszip__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(jszip__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\nclass DocumentProcessor {\n    async processDocument(file, bookName, styles, transitions, removalPrompts, postProcessing, onProgress) {\n        const startTime = Date.now();\n        try {\n            var _zip_folder, _zip_folder1;\n            onProgress === null || onProgress === void 0 ? void 0 : onProgress(5, \"Lendo documento...\");\n            // Read document content\n            const arrayBuffer = await file.arrayBuffer();\n            const result = await mammoth__WEBPACK_IMPORTED_MODULE_0__.extractRawText({\n                arrayBuffer\n            });\n            const text = result.value;\n            // Extract paragraphs\n            const paragraphs = text.split(\"\\n\").filter((p)=>p.trim().length > 0);\n            onProgress === null || onProgress === void 0 ? void 0 : onProgress(20, \"Analisando estrutura do documento...\");\n            // OPTIMIZED BATCH PROCESSING - Fix redundancy issue\n            const processedParagraphs = await this.processParagraphsOptimized(paragraphs, styles, removalPrompts, onProgress);\n            // Apply post-processing if requested\n            if (postProcessing) {\n                onProgress === null || onProgress === void 0 ? void 0 : onProgress(65, \"Aplicando p\\xf3s-processamento...\");\n                this.applyPostProcessing(processedParagraphs, postProcessing);\n            }\n            onProgress === null || onProgress === void 0 ? void 0 : onProgress(70, \"Aplicando estilos e formata\\xe7\\xe3o...\");\n            // Create styled document\n            const doc = this.createStyledDocument(processedParagraphs, styles, bookName);\n            onProgress === null || onProgress === void 0 ? void 0 : onProgress(85, \"Criando arquivo sanitizado para InDesign...\");\n            // Create sanitized version for InDesign with consistent style naming\n            const sanitizedDoc = this.createSanitizedDocumentForInDesign(processedParagraphs, styles, bookName);\n            onProgress === null || onProgress === void 0 ? void 0 : onProgress(90, \"Gerando arquivos finais...\");\n            // Generate blobs\n            const [mainBlob, sanitizedBlob] = await Promise.all([\n                docx__WEBPACK_IMPORTED_MODULE_1__.Packer.toBlob(doc),\n                docx__WEBPACK_IMPORTED_MODULE_1__.Packer.toBlob(sanitizedDoc)\n            ]);\n            // Create ZIP with all files\n            const zip = new (jszip__WEBPACK_IMPORTED_MODULE_2___default())();\n            const timestamp = new Date().toISOString().replace(/[:.]/g, \"-\");\n            const folderName = \"\".concat(bookName, \"_\").concat(timestamp);\n            (_zip_folder = zip.folder(folderName)) === null || _zip_folder === void 0 ? void 0 : _zip_folder.file(\"completo.docx\", mainBlob);\n            (_zip_folder1 = zip.folder(folderName)) === null || _zip_folder1 === void 0 ? void 0 : _zip_folder1.file(\"completo_pronto_para_indesign.docx\", sanitizedBlob);\n            const zipBlob = await zip.generateAsync({\n                type: \"blob\"\n            });\n            const processingTime = Math.round((Date.now() - startTime) / 1000);\n            onProgress === null || onProgress === void 0 ? void 0 : onProgress(100, \"Processamento conclu\\xeddo!\");\n            return {\n                success: true,\n                documentBlob: mainBlob,\n                zipBlob,\n                stats: {\n                    totalPages: Math.ceil(paragraphs.length / 30),\n                    totalParagraphs: paragraphs.length,\n                    questionsProcessed: processedParagraphs.filter((p)=>p.style === \"enunciado\" || p.style === \"questao\").length,\n                    apiCalls: Math.ceil(paragraphs.length / 25),\n                    estimatedCostUSD: Math.ceil(paragraphs.length / 25) * 0.002\n                },\n                files: [\n                    {\n                        name: \"completo.docx\",\n                        size: this.formatFileSize(mainBlob.size),\n                        path: \"completo.docx\"\n                    },\n                    {\n                        name: \"completo_pronto_para_indesign.docx\",\n                        size: this.formatFileSize(sanitizedBlob.size),\n                        path: \"completo_pronto_para_indesign.docx\"\n                    }\n                ],\n                processingTime: \"\".concat(Math.floor(processingTime / 60), \"m \").concat(processingTime % 60, \"s\")\n            };\n        } catch (error) {\n            console.error(\"Erro no processamento:\", error);\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : \"Erro desconhecido no processamento\"\n            };\n        }\n    }\n    async processParagraphsOptimized(paragraphs, styles, removalPrompts, onProgress) {\n        const processedParagraphs = [];\n        let apiCalls = 0;\n        // OPTIMIZED: Balance between context and accuracy\n        // 20-25 paragraphs gives enough context without overwhelming the AI\n        const batchSize = 25; // Optimal for accuracy with context\n        for(let i = 0; i < paragraphs.length; i += batchSize){\n            const batch = paragraphs.slice(i, Math.min(i + batchSize, paragraphs.length));\n            // Add some context from previous batch for continuity (last 3 paragraphs)\n            let contextBatch = batch;\n            if (i > 0 && processedParagraphs.length >= 3) {\n                const previousContext = paragraphs.slice(Math.max(0, i - 3), i);\n                contextBatch = [\n                    ...previousContext,\n                    ...batch\n                ];\n            }\n            // Build context-aware prompt\n            const prompt = this.buildOptimizedPrompt(contextBatch, styles, removalPrompts, i, paragraphs.length, i > 0 ? 3 : 0);\n            try {\n                // Call our backend API instead of OpenAI directly\n                const systemPrompt = \"Voc\\xea \\xe9 um assistente especializado em formatar documentos educacionais.\\nAnalise o texto e marque CADA par\\xe1grafo com tags XML apropriadas.\\nIMPORTANTE: \\n- Marque TODOS os par\\xe1grafos, mesmo que n\\xe3o correspondam a nenhum estilo espec\\xedfico (use <normal> para texto comum)\\n- Mantenha a ordem exata dos par\\xe1grafos\\n- Para remo\\xe7\\xf5es, use as tags de in\\xedcio e fim especificadas\";\n                const apiResponse = await fetch(\"/api/process-document\", {\n                    method: \"POST\",\n                    headers: {\n                        \"Content-Type\": \"application/json\"\n                    },\n                    body: JSON.stringify({\n                        paragraphs: contextBatch,\n                        systemPrompt: systemPrompt + \"\\n\\n\" + prompt,\n                        userId: \"current-user\" // This would come from auth context in production\n                    })\n                });\n                if (!apiResponse.ok) {\n                    const error = await apiResponse.json();\n                    throw new Error(error.error || \"Failed to process document\");\n                }\n                const { processedParagraphs, creditsRemaining, plan } = await apiResponse.json();\n                apiCalls++;\n                const markedContent = processedParagraphs.join(\"\\n\\n\");\n                // Parse marked content\n                const parsed = this.parseMarkedContent(markedContent, styles);\n                processedParagraphs.push(...parsed);\n                const progress = 20 + (i + batchSize) / paragraphs.length * 50;\n                onProgress === null || onProgress === void 0 ? void 0 : onProgress(Math.min(progress, 70), \"Processando \".concat(Math.min(i + batchSize, paragraphs.length), \"/\").concat(paragraphs.length, \" par\\xe1grafos...\"));\n            } catch (error) {\n                console.error(\"Erro ao processar batch:\", error);\n                // Add unprocessed paragraphs as normal text\n                batch.forEach((text)=>{\n                    processedParagraphs.push({\n                        text,\n                        style: \"normal\",\n                        remove: false,\n                        type: \"text\"\n                    });\n                });\n            }\n        }\n        return processedParagraphs;\n    }\n    buildOptimizedPrompt(batch, styles, removalPrompts, startIndex, totalParagraphs) {\n        let contextOffset = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 0;\n        const actualStart = startIndex - contextOffset + 1;\n        const actualEnd = Math.min(startIndex + batch.length - contextOffset, totalParagraphs);\n        let prompt = \"Contexto: Analisando par\\xe1grafos \".concat(actualStart, \" a \").concat(actualEnd, \" de um total de \").concat(totalParagraphs, \".\\n\");\n        if (contextOffset > 0) {\n            prompt += \"Nota: Os primeiros \".concat(contextOffset, \" par\\xe1grafos s\\xe3o contexto da batch anterior (j\\xe1 processados).\\n\");\n        }\n        prompt += \"\\n\";\n        prompt += \"ESTILOS DISPON\\xcdVEIS:\\n\";\n        styles.forEach((style)=>{\n            if (style.elementType === \"text\") {\n                prompt += \"<\".concat(style.marker.replace(/[\\[\\]]/g, \"\"), \"> - \").concat(style.prompt, \"\\n\");\n            }\n        });\n        prompt += \"\\nREMO\\xc7\\xd5ES:\\n\";\n        removalPrompts.forEach((removal)=>{\n            prompt += \"\".concat(removal.startMarker, \" e \").concat(removal.endMarker, \" - \").concat(removal.prompt, \"\\n\");\n        });\n        prompt += \"\\nTEXTO PARA ANALISAR:\\n\";\n        batch.forEach((para, index)=>{\n            prompt += \"[P\".concat(startIndex + index + 1, \"] \").concat(para, \"\\n\");\n        });\n        prompt += \"\\nRETORNE o texto marcado mantendo a numera\\xe7\\xe3o [P#] e aplicando as tags apropriadas.\\nExemplo de sa\\xedda:\\n[P1] <TITULO_SIMULADO>Simulado 1</TITULO_SIMULADO>\\n[P2] <normal>Texto comum sem estilo espec\\xedfico</normal>\\n[P3] <ENUNCIADO>1. Qual \\xe9 a capital do Brasil?</ENUNCIADO>\\n[P4] <ALTERNATIVA>a) S\\xe3o Paulo</ALTERNATIVA>\";\n        return prompt;\n    }\n    parseMarkedContent(content, styles) {\n        const parsed = [];\n        const lines = content.split(\"\\n\");\n        for (const line of lines){\n            if (!line.trim()) continue;\n            // Extract paragraph number if present\n            const paraMatch = line.match(/\\[P\\d+\\]/);\n            const cleanLine = paraMatch ? line.replace(paraMatch[0], \"\").trim() : line.trim();\n            let matched = false;\n            // Check for removal markers\n            if (cleanLine.includes(\"REMOVE\") && (cleanLine.includes(\"START\") || cleanLine.includes(\"END\"))) {\n                parsed.push({\n                    text: this.extractText(cleanLine),\n                    style: null,\n                    remove: true,\n                    type: \"text\"\n                });\n                matched = true;\n            } else {\n                // Check for style markers\n                for (const style of styles){\n                    const marker = style.marker.replace(/[\\[\\]]/g, \"\");\n                    const tagRegex = new RegExp(\"<\".concat(marker, \">(.*?)</\").concat(marker, \">\"), \"i\");\n                    const match = cleanLine.match(tagRegex);\n                    if (match) {\n                        parsed.push({\n                            text: match[1].trim(),\n                            style: style.id,\n                            remove: false,\n                            type: style.elementType\n                        });\n                        matched = true;\n                        break;\n                    }\n                }\n            }\n            // If no match, check for normal tag or add as normal text\n            if (!matched) {\n                const normalMatch = cleanLine.match(/<normal>(.*?)<\\/normal>/i);\n                if (normalMatch) {\n                    parsed.push({\n                        text: normalMatch[1].trim(),\n                        style: \"normal\",\n                        remove: false,\n                        type: \"text\"\n                    });\n                } else {\n                    const cleanText = this.extractText(cleanLine);\n                    if (cleanText) {\n                        parsed.push({\n                            text: cleanText,\n                            style: \"normal\",\n                            remove: false,\n                            type: \"text\"\n                        });\n                    }\n                }\n            }\n        }\n        return parsed;\n    }\n    extractText(line) {\n        return line.replace(/<[^>]*>/g, \"\").replace(/\\[P\\d+\\]/, \"\").trim();\n    }\n    createStyledDocument(processedParagraphs, styles, bookName) {\n        const children = [];\n        // Add title\n        children.push(new docx__WEBPACK_IMPORTED_MODULE_1__.Paragraph({\n            alignment: docx__WEBPACK_IMPORTED_MODULE_1__.AlignmentType.CENTER,\n            children: [\n                new docx__WEBPACK_IMPORTED_MODULE_1__.TextRun({\n                    text: bookName,\n                    bold: true,\n                    size: 32,\n                    color: \"1e40af\"\n                })\n            ],\n            spacing: {\n                after: 400\n            }\n        }));\n        // Process paragraphs\n        for (const para of processedParagraphs){\n            var _style_wordStyle, _formatting_color;\n            if (para.remove) continue;\n            const style = styles.find((s)=>s.id === para.style);\n            const formatting = (style === null || style === void 0 ? void 0 : style.formatting) || {};\n            let alignment = docx__WEBPACK_IMPORTED_MODULE_1__.AlignmentType.LEFT;\n            if (formatting.alignment === \"center\") alignment = docx__WEBPACK_IMPORTED_MODULE_1__.AlignmentType.CENTER;\n            if (formatting.alignment === \"right\") alignment = docx__WEBPACK_IMPORTED_MODULE_1__.AlignmentType.RIGHT;\n            if (formatting.alignment === \"justify\") alignment = docx__WEBPACK_IMPORTED_MODULE_1__.AlignmentType.JUSTIFIED;\n            const isHeading = style === null || style === void 0 ? void 0 : (_style_wordStyle = style.wordStyle) === null || _style_wordStyle === void 0 ? void 0 : _style_wordStyle.toLowerCase().includes(\"heading\");\n            children.push(new docx__WEBPACK_IMPORTED_MODULE_1__.Paragraph({\n                alignment,\n                heading: isHeading ? docx__WEBPACK_IMPORTED_MODULE_1__.HeadingLevel.HEADING_2 : undefined,\n                children: [\n                    new docx__WEBPACK_IMPORTED_MODULE_1__.TextRun({\n                        text: para.text,\n                        bold: formatting.bold || false,\n                        italics: formatting.italic || false,\n                        underline: formatting.underline ? {} : undefined,\n                        size: formatting.fontSize ? formatting.fontSize * 2 : 24,\n                        color: ((_formatting_color = formatting.color) === null || _formatting_color === void 0 ? void 0 : _formatting_color.replace(\"#\", \"\")) || \"000000\"\n                    })\n                ],\n                spacing: {\n                    after: 200\n                }\n            }));\n        }\n        return new docx__WEBPACK_IMPORTED_MODULE_1__.Document({\n            sections: [\n                {\n                    properties: {},\n                    children\n                }\n            ]\n        });\n    }\n    applyPostProcessing(paragraphs, options) {\n        paragraphs.forEach((para)=>{\n            if (para.remove) return;\n            let text = para.text;\n            // Remove question numbers if requested\n            if (options.removeQuestionNumbers && (para.style === \"enunciado\" || para.style === \"questao\")) {\n                // Remove patterns like \"1.\", \"1)\", \"01.\", \"Q1:\", etc.\n                text = text.replace(/^(\\d+[\\.\\)]\\s*|Q\\d+:?\\s*|\\d+\\s*-\\s*)/i, \"\");\n            }\n            // Remove alternative letters if requested\n            if (options.removeAlternativeLetters && para.style === \"alternativa\") {\n                // Remove patterns like \"a)\", \"A.\", \"(a)\", \"[A]\", etc.\n                text = text.replace(/^(\\(?[a-eA-E][\\.\\)]\\)?|\\[[a-eA-E]\\])\\s*/i, \"\");\n            }\n            // Apply custom removals\n            if (options.customRemovals && options.customRemovals.length > 0) {\n                options.customRemovals.forEach((pattern)=>{\n                    try {\n                        const regex = new RegExp(pattern, \"gi\");\n                        text = text.replace(regex, \"\");\n                    } catch (e) {\n                        // If regex is invalid, try literal replacement\n                        text = text.replace(new RegExp(pattern.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\"), \"gi\"), \"\");\n                    }\n                });\n            }\n            para.text = text.trim();\n        });\n    }\n    createSanitizedDocumentForInDesign(processedParagraphs, styles, bookName) {\n        const children = [];\n        // Create a style map to ensure consistent naming for InDesign\n        const styleMap = new Map();\n        styles.forEach((style)=>{\n            // Use the Word style name for InDesign consistency\n            // This prevents duplicate styles with same names\n            styleMap.set(style.id, style.wordStyle);\n        });\n        // Add document header with style definitions for InDesign\n        children.push(new docx__WEBPACK_IMPORTED_MODULE_1__.Paragraph({\n            children: [\n                new docx__WEBPACK_IMPORTED_MODULE_1__.TextRun({\n                    text: \"[INDESIGN_STYLES_START]\",\n                    size: 20\n                })\n            ]\n        }));\n        // List all styles for InDesign to recognize\n        styles.forEach((style)=>{\n            children.push(new docx__WEBPACK_IMPORTED_MODULE_1__.Paragraph({\n                children: [\n                    new docx__WEBPACK_IMPORTED_MODULE_1__.TextRun({\n                        text: \"[STYLE_DEF] \".concat(style.wordStyle, \" = \").concat(style.marker),\n                        size: 20\n                    })\n                ]\n            }));\n        });\n        children.push(new docx__WEBPACK_IMPORTED_MODULE_1__.Paragraph({\n            children: [\n                new docx__WEBPACK_IMPORTED_MODULE_1__.TextRun({\n                    text: \"[INDESIGN_STYLES_END]\",\n                    size: 20\n                })\n            ],\n            spacing: {\n                after: 400\n            }\n        }));\n        // Process paragraphs with consistent style naming\n        for (const para of processedParagraphs){\n            if (para.remove) continue;\n            const style = styles.find((s)=>s.id === para.style);\n            const styleName = styleMap.get(para.style || \"\") || \"Normal\";\n            // Use consistent style naming for InDesign\n            children.push(new docx__WEBPACK_IMPORTED_MODULE_1__.Paragraph({\n                children: [\n                    new docx__WEBPACK_IMPORTED_MODULE_1__.TextRun({\n                        text: \"[\".concat(styleName, \"] \").concat(para.text),\n                        size: 24\n                    })\n                ],\n                spacing: {\n                    after: 120\n                }\n            }));\n        }\n        return new docx__WEBPACK_IMPORTED_MODULE_1__.Document({\n            sections: [\n                {\n                    properties: {},\n                    children\n                }\n            ]\n        });\n    }\n    formatFileSize(bytes) {\n        if (bytes < 1024) return bytes + \" B\";\n        if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + \" KB\";\n        return (bytes / (1024 * 1024)).toFixed(1) + \" MB\";\n    }\n    constructor(){\n    // API key is now handled server-side\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy9kb2N1bWVudFByb2Nlc3Nvci50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUE4QjtBQUM0RztBQUNoSDtBQXVFbkIsTUFBTVE7SUFLWCxNQUFNQyxnQkFDSkMsSUFBVSxFQUNWQyxRQUFnQixFQUNoQkMsTUFBZSxFQUNmQyxXQUF5QixFQUN6QkMsY0FBK0IsRUFDL0JDLGNBQXNDLEVBQ3RDQyxVQUF3RCxFQUM3QjtRQUMzQixNQUFNQyxZQUFZQyxLQUFLQyxHQUFHO1FBRTFCLElBQUk7Z0JBa0RGQyxhQUNBQTtZQWxEQUosdUJBQUFBLGlDQUFBQSxXQUFhLEdBQUc7WUFFaEIsd0JBQXdCO1lBQ3hCLE1BQU1LLGNBQWMsTUFBTVgsS0FBS1csV0FBVztZQUMxQyxNQUFNQyxTQUFTLE1BQU10QixtREFBc0IsQ0FBQztnQkFBRXFCO1lBQVk7WUFDMUQsTUFBTUcsT0FBT0YsT0FBT0csS0FBSztZQUV6QixxQkFBcUI7WUFDckIsTUFBTUMsYUFBYUYsS0FBS0csS0FBSyxDQUFDLE1BQU1DLE1BQU0sQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRUMsSUFBSSxHQUFHQyxNQUFNLEdBQUc7WUFFbEVmLHVCQUFBQSxpQ0FBQUEsV0FBYSxJQUFJO1lBRWpCLG9EQUFvRDtZQUNwRCxNQUFNZ0Isc0JBQXNCLE1BQU0sSUFBSSxDQUFDQywwQkFBMEIsQ0FDL0RQLFlBQ0FkLFFBQ0FFLGdCQUNBRTtZQUdGLHFDQUFxQztZQUNyQyxJQUFJRCxnQkFBZ0I7Z0JBQ2xCQyx1QkFBQUEsaUNBQUFBLFdBQWEsSUFBSTtnQkFDakIsSUFBSSxDQUFDa0IsbUJBQW1CLENBQUNGLHFCQUFxQmpCO1lBQ2hEO1lBRUFDLHVCQUFBQSxpQ0FBQUEsV0FBYSxJQUFJO1lBRWpCLHlCQUF5QjtZQUN6QixNQUFNbUIsTUFBTSxJQUFJLENBQUNDLG9CQUFvQixDQUFDSixxQkFBcUJwQixRQUFRRDtZQUVuRUssdUJBQUFBLGlDQUFBQSxXQUFhLElBQUk7WUFF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S0FBSztJQUM5QztJQTljQUMsYUFBYztJQUNaLHFDQUFxQztJQUN2QztBQTZjRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvdXRpbHMvZG9jdW1lbnRQcm9jZXNzb3IudHM/OWQ1ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbWFtbW90aCBmcm9tICdtYW1tb3RoJztcbmltcG9ydCB7IERvY3VtZW50LCBQYWNrZXIsIFBhcmFncmFwaCwgVGV4dFJ1biwgSGVhZGluZ0xldmVsLCBBbGlnbm1lbnRUeXBlLCBUYWJsZSwgVGFibGVSb3csIFRhYmxlQ2VsbCwgV2lkdGhUeXBlLCBJbWFnZVJ1biB9IGZyb20gJ2RvY3gnO1xuaW1wb3J0IEpTWmlwIGZyb20gJ2pzemlwJztcblxuZXhwb3J0IGludGVyZmFjZSBTdHlsZUZvcm1hdHRpbmcge1xuICBib2xkPzogYm9vbGVhbjtcbiAgaXRhbGljPzogYm9vbGVhbjtcbiAgdW5kZXJsaW5lPzogYm9vbGVhbjtcbiAgZm9udFNpemU/OiBudW1iZXI7XG4gIGNvbG9yPzogc3RyaW5nO1xuICBhbGlnbm1lbnQ/OiAnbGVmdCcgfCAnY2VudGVyJyB8ICdyaWdodCcgfCAnanVzdGlmeSc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3R5bGUge1xuICBpZDogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIHdvcmRTdHlsZTogc3RyaW5nO1xuICBtYXJrZXI6IHN0cmluZztcbiAgcHJvbXB0OiBzdHJpbmc7XG4gIGNvbG9yOiBzdHJpbmc7XG4gIG9yZGVyOiBudW1iZXI7XG4gIGVsZW1lbnRUeXBlOiAndGV4dCcgfCAnaW1hZ2UnIHwgJ3RhYmxlJztcbiAgaGFzUmVzaWR1ZT86IGJvb2xlYW47XG4gIGFsbG93SW5saW5lSW1hZ2VzPzogYm9vbGVhbjtcbiAgZm9ybWF0dGluZz86IFN0eWxlRm9ybWF0dGluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUcmFuc2l0aW9uIHtcbiAgZnJvbTogbnVtYmVyO1xuICB0bzogbnVtYmVyO1xuICB0eXBlOiAnbm9uZScgfCAncmVxdWlyZWQnIHwgJ29wdGlvbmFsJztcbiAgYWx0ZXJuYXRpdmVzOiBudW1iZXJbXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZW1vdmFsUHJvbXB0IHtcbiAgaWQ6IHN0cmluZztcbiAgbmFtZTogc3RyaW5nO1xuICBzdGFydE1hcmtlcjogc3RyaW5nO1xuICBlbmRNYXJrZXI6IHN0cmluZztcbiAgcHJvbXB0OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUG9zdFByb2Nlc3NpbmdPcHRpb25zIHtcbiAgcmVtb3ZlUXVlc3Rpb25OdW1iZXJzPzogYm9vbGVhbjtcbiAgcmVtb3ZlQWx0ZXJuYXRpdmVMZXR0ZXJzPzogYm9vbGVhbjtcbiAgY3VzdG9tUmVtb3ZhbHM/OiBzdHJpbmdbXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQcm9jZXNzaW5nUmVzdWx0IHtcbiAgc3VjY2VzczogYm9vbGVhbjtcbiAgZG9jdW1lbnRCbG9iPzogQmxvYjtcbiAgemlwQmxvYj86IEJsb2I7XG4gIHN0YXRzPzoge1xuICAgIHRvdGFsUGFnZXM6IG51bWJlcjtcbiAgICB0b3RhbFBhcmFncmFwaHM6IG51bWJlcjtcbiAgICBxdWVzdGlvbnNQcm9jZXNzZWQ6IG51bWJlcjtcbiAgICBhcGlDYWxsczogbnVtYmVyO1xuICAgIGVzdGltYXRlZENvc3RVU0Q6IG51bWJlcjtcbiAgfTtcbiAgZmlsZXM/OiBBcnJheTx7bmFtZTogc3RyaW5nOyBzaXplOiBzdHJpbmc7IHBhdGg6IHN0cmluZ30+O1xuICBlcnJvcj86IHN0cmluZztcbiAgcHJvY2Vzc2luZ1RpbWU/OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBQcm9jZXNzZWRQYXJhZ3JhcGgge1xuICB0ZXh0OiBzdHJpbmc7XG4gIHN0eWxlOiBzdHJpbmcgfCBudWxsO1xuICByZW1vdmU6IGJvb2xlYW47XG4gIHR5cGU6ICd0ZXh0JyB8ICdpbWFnZScgfCAndGFibGUnO1xuICBpbWFnZURhdGE/OiBzdHJpbmc7XG4gIHRhYmxlRGF0YT86IGFueVtdW107XG59XG5cbmV4cG9ydCBjbGFzcyBEb2N1bWVudFByb2Nlc3NvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8vIEFQSSBrZXkgaXMgbm93IGhhbmRsZWQgc2VydmVyLXNpZGVcbiAgfVxuXG4gIGFzeW5jIHByb2Nlc3NEb2N1bWVudChcbiAgICBmaWxlOiBGaWxlLFxuICAgIGJvb2tOYW1lOiBzdHJpbmcsXG4gICAgc3R5bGVzOiBTdHlsZVtdLFxuICAgIHRyYW5zaXRpb25zOiBUcmFuc2l0aW9uW10sXG4gICAgcmVtb3ZhbFByb21wdHM6IFJlbW92YWxQcm9tcHRbXSxcbiAgICBwb3N0UHJvY2Vzc2luZz86IFBvc3RQcm9jZXNzaW5nT3B0aW9ucyxcbiAgICBvblByb2dyZXNzPzogKHByb2dyZXNzOiBudW1iZXIsIG1lc3NhZ2U6IHN0cmluZykgPT4gdm9pZFxuICApOiBQcm9taXNlPFByb2Nlc3NpbmdSZXN1bHQ+IHtcbiAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICBvblByb2dyZXNzPy4oNSwgJ0xlbmRvIGRvY3VtZW50by4uLicpO1xuICAgICAgXG4gICAgICAvLyBSZWFkIGRvY3VtZW50IGNvbnRlbnRcbiAgICAgIGNvbnN0IGFycmF5QnVmZmVyID0gYXdhaXQgZmlsZS5hcnJheUJ1ZmZlcigpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbWFtbW90aC5leHRyYWN0UmF3VGV4dCh7IGFycmF5QnVmZmVyIH0pO1xuICAgICAgY29uc3QgdGV4dCA9IHJlc3VsdC52YWx1ZTtcbiAgICAgIFxuICAgICAgLy8gRXh0cmFjdCBwYXJhZ3JhcGhzXG4gICAgICBjb25zdCBwYXJhZ3JhcGhzID0gdGV4dC5zcGxpdCgnXFxuJykuZmlsdGVyKHAgPT4gcC50cmltKCkubGVuZ3RoID4gMCk7XG4gICAgICBcbiAgICAgIG9uUHJvZ3Jlc3M/LigyMCwgJ0FuYWxpc2FuZG8gZXN0cnV0dXJhIGRvIGRvY3VtZW50by4uLicpO1xuICAgICAgXG4gICAgICAvLyBPUFRJTUlaRUQgQkFUQ0ggUFJPQ0VTU0lORyAtIEZpeCByZWR1bmRhbmN5IGlzc3VlXG4gICAgICBjb25zdCBwcm9jZXNzZWRQYXJhZ3JhcGhzID0gYXdhaXQgdGhpcy5wcm9jZXNzUGFyYWdyYXBoc09wdGltaXplZChcbiAgICAgICAgcGFyYWdyYXBocyxcbiAgICAgICAgc3R5bGVzLFxuICAgICAgICByZW1vdmFsUHJvbXB0cyxcbiAgICAgICAgb25Qcm9ncmVzc1xuICAgICAgKTtcbiAgICAgIFxuICAgICAgLy8gQXBwbHkgcG9zdC1wcm9jZXNzaW5nIGlmIHJlcXVlc3RlZFxuICAgICAgaWYgKHBvc3RQcm9jZXNzaW5nKSB7XG4gICAgICAgIG9uUHJvZ3Jlc3M/Lig2NSwgJ0FwbGljYW5kbyBww7NzLXByb2Nlc3NhbWVudG8uLi4nKTtcbiAgICAgICAgdGhpcy5hcHBseVBvc3RQcm9jZXNzaW5nKHByb2Nlc3NlZFBhcmFncmFwaHMsIHBvc3RQcm9jZXNzaW5nKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgb25Qcm9ncmVzcz8uKDcwLCAnQXBsaWNhbmRvIGVzdGlsb3MgZSBmb3JtYXRhw6fDo28uLi4nKTtcbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIHN0eWxlZCBkb2N1bWVudFxuICAgICAgY29uc3QgZG9jID0gdGhpcy5jcmVhdGVTdHlsZWREb2N1bWVudChwcm9jZXNzZWRQYXJhZ3JhcGhzLCBzdHlsZXMsIGJvb2tOYW1lKTtcbiAgICAgIFxuICAgICAgb25Qcm9ncmVzcz8uKDg1LCAnQ3JpYW5kbyBhcnF1aXZvIHNhbml0aXphZG8gcGFyYSBJbkRlc2lnbi4uLicpO1xuICAgICAgXG4gICAgICAvLyBDcmVhdGUgc2FuaXRpemVkIHZlcnNpb24gZm9yIEluRGVzaWduIHdpdGggY29uc2lzdGVudCBzdHlsZSBuYW1pbmdcbiAgICAgIGNvbnN0IHNhbml0aXplZERvYyA9IHRoaXMuY3JlYXRlU2FuaXRpemVkRG9jdW1lbnRGb3JJbkRlc2lnbihwcm9jZXNzZWRQYXJhZ3JhcGhzLCBzdHlsZXMsIGJvb2tOYW1lKTtcbiAgICAgIFxuICAgICAgb25Qcm9ncmVzcz8uKDkwLCAnR2VyYW5kbyBhcnF1aXZvcyBmaW5haXMuLi4nKTtcbiAgICAgIFxuICAgICAgLy8gR2VuZXJhdGUgYmxvYnNcbiAgICAgIGNvbnN0IFttYWluQmxvYiwgc2FuaXRpemVkQmxvYl0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgIFBhY2tlci50b0Jsb2IoZG9jKSxcbiAgICAgICAgUGFja2VyLnRvQmxvYihzYW5pdGl6ZWREb2MpXG4gICAgICBdKTtcbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIFpJUCB3aXRoIGFsbCBmaWxlc1xuICAgICAgY29uc3QgemlwID0gbmV3IEpTWmlwKCk7XG4gICAgICBjb25zdCB0aW1lc3RhbXAgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkucmVwbGFjZSgvWzouXS9nLCAnLScpO1xuICAgICAgY29uc3QgZm9sZGVyTmFtZSA9IGAke2Jvb2tOYW1lfV8ke3RpbWVzdGFtcH1gO1xuICAgICAgXG4gICAgICB6aXAuZm9sZGVyKGZvbGRlck5hbWUpPy5maWxlKCdjb21wbGV0by5kb2N4JywgbWFpbkJsb2IpO1xuICAgICAgemlwLmZvbGRlcihmb2xkZXJOYW1lKT8uZmlsZSgnY29tcGxldG9fcHJvbnRvX3BhcmFfaW5kZXNpZ24uZG9jeCcsIHNhbml0aXplZEJsb2IpO1xuICAgICAgXG4gICAgICBjb25zdCB6aXBCbG9iID0gYXdhaXQgemlwLmdlbmVyYXRlQXN5bmMoeyB0eXBlOiAnYmxvYicgfSk7XG4gICAgICBcbiAgICAgIGNvbnN0IHByb2Nlc3NpbmdUaW1lID0gTWF0aC5yb3VuZCgoRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSkgLyAxMDAwKTtcbiAgICAgIFxuICAgICAgb25Qcm9ncmVzcz8uKDEwMCwgJ1Byb2Nlc3NhbWVudG8gY29uY2x1w61kbyEnKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgZG9jdW1lbnRCbG9iOiBtYWluQmxvYixcbiAgICAgICAgemlwQmxvYixcbiAgICAgICAgc3RhdHM6IHtcbiAgICAgICAgICB0b3RhbFBhZ2VzOiBNYXRoLmNlaWwocGFyYWdyYXBocy5sZW5ndGggLyAzMCksXG4gICAgICAgICAgdG90YWxQYXJhZ3JhcGhzOiBwYXJhZ3JhcGhzLmxlbmd0aCxcbiAgICAgICAgICBxdWVzdGlvbnNQcm9jZXNzZWQ6IHByb2Nlc3NlZFBhcmFncmFwaHMuZmlsdGVyKHAgPT4gcC5zdHlsZSA9PT0gJ2VudW5jaWFkbycgfHwgcC5zdHlsZSA9PT0gJ3F1ZXN0YW8nKS5sZW5ndGgsXG4gICAgICAgICAgYXBpQ2FsbHM6IE1hdGguY2VpbChwYXJhZ3JhcGhzLmxlbmd0aCAvIDI1KSwgLy8gQmFsYW5jZWQgYmF0Y2ggc2l6ZSBmb3IgYWNjdXJhY3lcbiAgICAgICAgICBlc3RpbWF0ZWRDb3N0VVNEOiBNYXRoLmNlaWwocGFyYWdyYXBocy5sZW5ndGggLyAyNSkgKiAwLjAwMlxuICAgICAgICB9LFxuICAgICAgICBmaWxlczogW1xuICAgICAgICAgIHsgbmFtZTogJ2NvbXBsZXRvLmRvY3gnLCBzaXplOiB0aGlzLmZvcm1hdEZpbGVTaXplKG1haW5CbG9iLnNpemUpLCBwYXRoOiAnY29tcGxldG8uZG9jeCcgfSxcbiAgICAgICAgICB7IG5hbWU6ICdjb21wbGV0b19wcm9udG9fcGFyYV9pbmRlc2lnbi5kb2N4Jywgc2l6ZTogdGhpcy5mb3JtYXRGaWxlU2l6ZShzYW5pdGl6ZWRCbG9iLnNpemUpLCBwYXRoOiAnY29tcGxldG9fcHJvbnRvX3BhcmFfaW5kZXNpZ24uZG9jeCcgfVxuICAgICAgICBdLFxuICAgICAgICBwcm9jZXNzaW5nVGltZTogYCR7TWF0aC5mbG9vcihwcm9jZXNzaW5nVGltZSAvIDYwKX1tICR7cHJvY2Vzc2luZ1RpbWUgJSA2MH1zYFxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJybyBubyBwcm9jZXNzYW1lbnRvOicsIGVycm9yKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnRXJybyBkZXNjb25oZWNpZG8gbm8gcHJvY2Vzc2FtZW50bydcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBwcm9jZXNzUGFyYWdyYXBoc09wdGltaXplZChcbiAgICBwYXJhZ3JhcGhzOiBzdHJpbmdbXSxcbiAgICBzdHlsZXM6IFN0eWxlW10sXG4gICAgcmVtb3ZhbFByb21wdHM6IFJlbW92YWxQcm9tcHRbXSxcbiAgICBvblByb2dyZXNzPzogKHByb2dyZXNzOiBudW1iZXIsIG1lc3NhZ2U6IHN0cmluZykgPT4gdm9pZFxuICApOiBQcm9taXNlPFByb2Nlc3NlZFBhcmFncmFwaFtdPiB7XG4gICAgY29uc3QgcHJvY2Vzc2VkUGFyYWdyYXBoczogUHJvY2Vzc2VkUGFyYWdyYXBoW10gPSBbXTtcbiAgICBsZXQgYXBpQ2FsbHMgPSAwO1xuICAgIFxuICAgIC8vIE9QVElNSVpFRDogQmFsYW5jZSBiZXR3ZWVuIGNvbnRleHQgYW5kIGFjY3VyYWN5XG4gICAgLy8gMjAtMjUgcGFyYWdyYXBocyBnaXZlcyBlbm91Z2ggY29udGV4dCB3aXRob3V0IG92ZXJ3aGVsbWluZyB0aGUgQUlcbiAgICBjb25zdCBiYXRjaFNpemUgPSAyNTsgLy8gT3B0aW1hbCBmb3IgYWNjdXJhY3kgd2l0aCBjb250ZXh0XG4gICAgXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJhZ3JhcGhzLmxlbmd0aDsgaSArPSBiYXRjaFNpemUpIHtcbiAgICAgIGNvbnN0IGJhdGNoID0gcGFyYWdyYXBocy5zbGljZShpLCBNYXRoLm1pbihpICsgYmF0Y2hTaXplLCBwYXJhZ3JhcGhzLmxlbmd0aCkpO1xuICAgICAgXG4gICAgICAvLyBBZGQgc29tZSBjb250ZXh0IGZyb20gcHJldmlvdXMgYmF0Y2ggZm9yIGNvbnRpbnVpdHkgKGxhc3QgMyBwYXJhZ3JhcGhzKVxuICAgICAgbGV0IGNvbnRleHRCYXRjaCA9IGJhdGNoO1xuICAgICAgaWYgKGkgPiAwICYmIHByb2Nlc3NlZFBhcmFncmFwaHMubGVuZ3RoID49IDMpIHtcbiAgICAgICAgY29uc3QgcHJldmlvdXNDb250ZXh0ID0gcGFyYWdyYXBocy5zbGljZShNYXRoLm1heCgwLCBpIC0gMyksIGkpO1xuICAgICAgICBjb250ZXh0QmF0Y2ggPSBbLi4ucHJldmlvdXNDb250ZXh0LCAuLi5iYXRjaF07XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEJ1aWxkIGNvbnRleHQtYXdhcmUgcHJvbXB0XG4gICAgICBjb25zdCBwcm9tcHQgPSB0aGlzLmJ1aWxkT3B0aW1pemVkUHJvbXB0KGNvbnRleHRCYXRjaCwgc3R5bGVzLCByZW1vdmFsUHJvbXB0cywgaSwgcGFyYWdyYXBocy5sZW5ndGgsIGkgPiAwID8gMyA6IDApO1xuICAgICAgXG4gICAgICB0cnkge1xuICAgICAgICAvLyBDYWxsIG91ciBiYWNrZW5kIEFQSSBpbnN0ZWFkIG9mIE9wZW5BSSBkaXJlY3RseVxuICAgICAgICBjb25zdCBzeXN0ZW1Qcm9tcHQgPSBgVm9jw6ogw6kgdW0gYXNzaXN0ZW50ZSBlc3BlY2lhbGl6YWRvIGVtIGZvcm1hdGFyIGRvY3VtZW50b3MgZWR1Y2FjaW9uYWlzLlxuQW5hbGlzZSBvIHRleHRvIGUgbWFycXVlIENBREEgcGFyw6FncmFmbyBjb20gdGFncyBYTUwgYXByb3ByaWFkYXMuXG5JTVBPUlRBTlRFOiBcbi0gTWFycXVlIFRPRE9TIG9zIHBhcsOhZ3JhZm9zLCBtZXNtbyBxdWUgbsOjbyBjb3JyZXNwb25kYW0gYSBuZW5odW0gZXN0aWxvIGVzcGVjw61maWNvICh1c2UgPG5vcm1hbD4gcGFyYSB0ZXh0byBjb211bSlcbi0gTWFudGVuaGEgYSBvcmRlbSBleGF0YSBkb3MgcGFyw6FncmFmb3Ncbi0gUGFyYSByZW1vw6fDtWVzLCB1c2UgYXMgdGFncyBkZSBpbsOtY2lvIGUgZmltIGVzcGVjaWZpY2FkYXNgO1xuXG4gICAgICAgIGNvbnN0IGFwaVJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9hcGkvcHJvY2Vzcy1kb2N1bWVudCcsIHtcbiAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgcGFyYWdyYXBoczogY29udGV4dEJhdGNoLFxuICAgICAgICAgICAgc3lzdGVtUHJvbXB0OiBzeXN0ZW1Qcm9tcHQgKyAnXFxuXFxuJyArIHByb21wdCxcbiAgICAgICAgICAgIHVzZXJJZDogJ2N1cnJlbnQtdXNlcicgLy8gVGhpcyB3b3VsZCBjb21lIGZyb20gYXV0aCBjb250ZXh0IGluIHByb2R1Y3Rpb25cbiAgICAgICAgICB9KVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIWFwaVJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3IgPSBhd2FpdCBhcGlSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yLmVycm9yIHx8ICdGYWlsZWQgdG8gcHJvY2VzcyBkb2N1bWVudCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyBwcm9jZXNzZWRQYXJhZ3JhcGhzLCBjcmVkaXRzUmVtYWluaW5nLCBwbGFuIH0gPSBhd2FpdCBhcGlSZXNwb25zZS5qc29uKCk7XG4gICAgICAgIFxuICAgICAgICBhcGlDYWxscysrO1xuICAgICAgICBjb25zdCBtYXJrZWRDb250ZW50ID0gcHJvY2Vzc2VkUGFyYWdyYXBocy5qb2luKCdcXG5cXG4nKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFBhcnNlIG1hcmtlZCBjb250ZW50XG4gICAgICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMucGFyc2VNYXJrZWRDb250ZW50KG1hcmtlZENvbnRlbnQsIHN0eWxlcyk7XG4gICAgICAgIHByb2Nlc3NlZFBhcmFncmFwaHMucHVzaCguLi5wYXJzZWQpO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgcHJvZ3Jlc3MgPSAyMCArICgoaSArIGJhdGNoU2l6ZSkgLyBwYXJhZ3JhcGhzLmxlbmd0aCkgKiA1MDtcbiAgICAgICAgb25Qcm9ncmVzcz8uKE1hdGgubWluKHByb2dyZXNzLCA3MCksIGBQcm9jZXNzYW5kbyAke01hdGgubWluKGkgKyBiYXRjaFNpemUsIHBhcmFncmFwaHMubGVuZ3RoKX0vJHtwYXJhZ3JhcGhzLmxlbmd0aH0gcGFyw6FncmFmb3MuLi5gKTtcbiAgICAgICAgXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvIGFvIHByb2Nlc3NhciBiYXRjaDonLCBlcnJvcik7XG4gICAgICAgIC8vIEFkZCB1bnByb2Nlc3NlZCBwYXJhZ3JhcGhzIGFzIG5vcm1hbCB0ZXh0XG4gICAgICAgIGJhdGNoLmZvckVhY2godGV4dCA9PiB7XG4gICAgICAgICAgcHJvY2Vzc2VkUGFyYWdyYXBocy5wdXNoKHsgdGV4dCwgc3R5bGU6ICdub3JtYWwnLCByZW1vdmU6IGZhbHNlLCB0eXBlOiAndGV4dCcgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gcHJvY2Vzc2VkUGFyYWdyYXBocztcbiAgfVxuXG4gIHByaXZhdGUgYnVpbGRPcHRpbWl6ZWRQcm9tcHQoYmF0Y2g6IHN0cmluZ1tdLCBzdHlsZXM6IFN0eWxlW10sIHJlbW92YWxQcm9tcHRzOiBSZW1vdmFsUHJvbXB0W10sIHN0YXJ0SW5kZXg6IG51bWJlciwgdG90YWxQYXJhZ3JhcGhzOiBudW1iZXIsIGNvbnRleHRPZmZzZXQ6IG51bWJlciA9IDApOiBzdHJpbmcge1xuICAgIGNvbnN0IGFjdHVhbFN0YXJ0ID0gc3RhcnRJbmRleCAtIGNvbnRleHRPZmZzZXQgKyAxO1xuICAgIGNvbnN0IGFjdHVhbEVuZCA9IE1hdGgubWluKHN0YXJ0SW5kZXggKyBiYXRjaC5sZW5ndGggLSBjb250ZXh0T2Zmc2V0LCB0b3RhbFBhcmFncmFwaHMpO1xuICAgIGxldCBwcm9tcHQgPSBgQ29udGV4dG86IEFuYWxpc2FuZG8gcGFyw6FncmFmb3MgJHthY3R1YWxTdGFydH0gYSAke2FjdHVhbEVuZH0gZGUgdW0gdG90YWwgZGUgJHt0b3RhbFBhcmFncmFwaHN9LlxcbmA7XG4gICAgaWYgKGNvbnRleHRPZmZzZXQgPiAwKSB7XG4gICAgICBwcm9tcHQgKz0gYE5vdGE6IE9zIHByaW1laXJvcyAke2NvbnRleHRPZmZzZXR9IHBhcsOhZ3JhZm9zIHPDo28gY29udGV4dG8gZGEgYmF0Y2ggYW50ZXJpb3IgKGrDoSBwcm9jZXNzYWRvcykuXFxuYDtcbiAgICB9XG4gICAgcHJvbXB0ICs9ICdcXG4nO1xuICAgIFxuICAgIHByb21wdCArPSBgRVNUSUxPUyBESVNQT07DjVZFSVM6XFxuYDtcbiAgICBzdHlsZXMuZm9yRWFjaChzdHlsZSA9PiB7XG4gICAgICBpZiAoc3R5bGUuZWxlbWVudFR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICBwcm9tcHQgKz0gYDwke3N0eWxlLm1hcmtlci5yZXBsYWNlKC9bXFxbXFxdXS9nLCAnJyl9PiAtICR7c3R5bGUucHJvbXB0fVxcbmA7XG4gICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgcHJvbXB0ICs9IGBcXG5SRU1Pw4fDlUVTOlxcbmA7XG4gICAgcmVtb3ZhbFByb21wdHMuZm9yRWFjaChyZW1vdmFsID0+IHtcbiAgICAgIHByb21wdCArPSBgJHtyZW1vdmFsLnN0YXJ0TWFya2VyfSBlICR7cmVtb3ZhbC5lbmRNYXJrZXJ9IC0gJHtyZW1vdmFsLnByb21wdH1cXG5gO1xuICAgIH0pO1xuICAgIFxuICAgIHByb21wdCArPSBgXFxuVEVYVE8gUEFSQSBBTkFMSVNBUjpcXG5gO1xuICAgIGJhdGNoLmZvckVhY2goKHBhcmEsIGluZGV4KSA9PiB7XG4gICAgICBwcm9tcHQgKz0gYFtQJHtzdGFydEluZGV4ICsgaW5kZXggKyAxfV0gJHtwYXJhfVxcbmA7XG4gICAgfSk7XG4gICAgXG4gICAgcHJvbXB0ICs9IGBcXG5SRVRPUk5FIG8gdGV4dG8gbWFyY2FkbyBtYW50ZW5kbyBhIG51bWVyYcOnw6NvIFtQI10gZSBhcGxpY2FuZG8gYXMgdGFncyBhcHJvcHJpYWRhcy5cbkV4ZW1wbG8gZGUgc2HDrWRhOlxuW1AxXSA8VElUVUxPX1NJTVVMQURPPlNpbXVsYWRvIDE8L1RJVFVMT19TSU1VTEFETz5cbltQMl0gPG5vcm1hbD5UZXh0byBjb211bSBzZW0gZXN0aWxvIGVzcGVjw61maWNvPC9ub3JtYWw+XG5bUDNdIDxFTlVOQ0lBRE8+MS4gUXVhbCDDqSBhIGNhcGl0YWwgZG8gQnJhc2lsPzwvRU5VTkNJQURPPlxuW1A0XSA8QUxURVJOQVRJVkE+YSkgU8OjbyBQYXVsbzwvQUxURVJOQVRJVkE+YDtcbiAgICBcbiAgICByZXR1cm4gcHJvbXB0O1xuICB9XG5cbiAgcHJpdmF0ZSBwYXJzZU1hcmtlZENvbnRlbnQoY29udGVudDogc3RyaW5nLCBzdHlsZXM6IFN0eWxlW10pOiBQcm9jZXNzZWRQYXJhZ3JhcGhbXSB7XG4gICAgY29uc3QgcGFyc2VkOiBQcm9jZXNzZWRQYXJhZ3JhcGhbXSA9IFtdO1xuICAgIGNvbnN0IGxpbmVzID0gY29udGVudC5zcGxpdCgnXFxuJyk7XG4gICAgXG4gICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgICBpZiAoIWxpbmUudHJpbSgpKSBjb250aW51ZTtcbiAgICAgIFxuICAgICAgLy8gRXh0cmFjdCBwYXJhZ3JhcGggbnVtYmVyIGlmIHByZXNlbnRcbiAgICAgIGNvbnN0IHBhcmFNYXRjaCA9IGxpbmUubWF0Y2goL1xcW1BcXGQrXFxdLyk7XG4gICAgICBjb25zdCBjbGVhbkxpbmUgPSBwYXJhTWF0Y2ggPyBsaW5lLnJlcGxhY2UocGFyYU1hdGNoWzBdLCAnJykudHJpbSgpIDogbGluZS50cmltKCk7XG4gICAgICBcbiAgICAgIGxldCBtYXRjaGVkID0gZmFsc2U7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGZvciByZW1vdmFsIG1hcmtlcnNcbiAgICAgIGlmIChjbGVhbkxpbmUuaW5jbHVkZXMoJ1JFTU9WRScpICYmIChjbGVhbkxpbmUuaW5jbHVkZXMoJ1NUQVJUJykgfHwgY2xlYW5MaW5lLmluY2x1ZGVzKCdFTkQnKSkpIHtcbiAgICAgICAgcGFyc2VkLnB1c2goeyBcbiAgICAgICAgICB0ZXh0OiB0aGlzLmV4dHJhY3RUZXh0KGNsZWFuTGluZSksIFxuICAgICAgICAgIHN0eWxlOiBudWxsLCBcbiAgICAgICAgICByZW1vdmU6IHRydWUsIFxuICAgICAgICAgIHR5cGU6ICd0ZXh0JyBcbiAgICAgICAgfSk7XG4gICAgICAgIG1hdGNoZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ2hlY2sgZm9yIHN0eWxlIG1hcmtlcnNcbiAgICAgICAgZm9yIChjb25zdCBzdHlsZSBvZiBzdHlsZXMpIHtcbiAgICAgICAgICBjb25zdCBtYXJrZXIgPSBzdHlsZS5tYXJrZXIucmVwbGFjZSgvW1xcW1xcXV0vZywgJycpO1xuICAgICAgICAgIGNvbnN0IHRhZ1JlZ2V4ID0gbmV3IFJlZ0V4cChgPCR7bWFya2VyfT4oLio/KTwvJHttYXJrZXJ9PmAsICdpJyk7XG4gICAgICAgICAgY29uc3QgbWF0Y2ggPSBjbGVhbkxpbmUubWF0Y2godGFnUmVnZXgpO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgcGFyc2VkLnB1c2goeyBcbiAgICAgICAgICAgICAgdGV4dDogbWF0Y2hbMV0udHJpbSgpLCBcbiAgICAgICAgICAgICAgc3R5bGU6IHN0eWxlLmlkLCBcbiAgICAgICAgICAgICAgcmVtb3ZlOiBmYWxzZSwgXG4gICAgICAgICAgICAgIHR5cGU6IHN0eWxlLmVsZW1lbnRUeXBlIFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBtYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBJZiBubyBtYXRjaCwgY2hlY2sgZm9yIG5vcm1hbCB0YWcgb3IgYWRkIGFzIG5vcm1hbCB0ZXh0XG4gICAgICBpZiAoIW1hdGNoZWQpIHtcbiAgICAgICAgY29uc3Qgbm9ybWFsTWF0Y2ggPSBjbGVhbkxpbmUubWF0Y2goLzxub3JtYWw+KC4qPyk8XFwvbm9ybWFsPi9pKTtcbiAgICAgICAgaWYgKG5vcm1hbE1hdGNoKSB7XG4gICAgICAgICAgcGFyc2VkLnB1c2goeyBcbiAgICAgICAgICAgIHRleHQ6IG5vcm1hbE1hdGNoWzFdLnRyaW0oKSwgXG4gICAgICAgICAgICBzdHlsZTogJ25vcm1hbCcsIFxuICAgICAgICAgICAgcmVtb3ZlOiBmYWxzZSwgXG4gICAgICAgICAgICB0eXBlOiAndGV4dCcgXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgY2xlYW5UZXh0ID0gdGhpcy5leHRyYWN0VGV4dChjbGVhbkxpbmUpO1xuICAgICAgICAgIGlmIChjbGVhblRleHQpIHtcbiAgICAgICAgICAgIHBhcnNlZC5wdXNoKHsgXG4gICAgICAgICAgICAgIHRleHQ6IGNsZWFuVGV4dCwgXG4gICAgICAgICAgICAgIHN0eWxlOiAnbm9ybWFsJywgXG4gICAgICAgICAgICAgIHJlbW92ZTogZmFsc2UsIFxuICAgICAgICAgICAgICB0eXBlOiAndGV4dCcgXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuXG4gIHByaXZhdGUgZXh0cmFjdFRleHQobGluZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gbGluZS5yZXBsYWNlKC88W14+XSo+L2csICcnKS5yZXBsYWNlKC9cXFtQXFxkK1xcXS8sICcnKS50cmltKCk7XG4gIH1cblxuICBwcml2YXRlIGNyZWF0ZVN0eWxlZERvY3VtZW50KHByb2Nlc3NlZFBhcmFncmFwaHM6IFByb2Nlc3NlZFBhcmFncmFwaFtdLCBzdHlsZXM6IFN0eWxlW10sIGJvb2tOYW1lOiBzdHJpbmcpOiBEb2N1bWVudCB7XG4gICAgY29uc3QgY2hpbGRyZW46IFBhcmFncmFwaFtdID0gW107XG4gICAgXG4gICAgLy8gQWRkIHRpdGxlXG4gICAgY2hpbGRyZW4ucHVzaChcbiAgICAgIG5ldyBQYXJhZ3JhcGgoe1xuICAgICAgICBhbGlnbm1lbnQ6IEFsaWdubWVudFR5cGUuQ0VOVEVSLFxuICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgIG5ldyBUZXh0UnVuKHtcbiAgICAgICAgICAgIHRleHQ6IGJvb2tOYW1lLFxuICAgICAgICAgICAgYm9sZDogdHJ1ZSxcbiAgICAgICAgICAgIHNpemU6IDMyLFxuICAgICAgICAgICAgY29sb3I6ICcxZTQwYWYnXG4gICAgICAgICAgfSlcbiAgICAgICAgXSxcbiAgICAgICAgc3BhY2luZzogeyBhZnRlcjogNDAwIH1cbiAgICAgIH0pXG4gICAgKTtcbiAgICBcbiAgICAvLyBQcm9jZXNzIHBhcmFncmFwaHNcbiAgICBmb3IgKGNvbnN0IHBhcmEgb2YgcHJvY2Vzc2VkUGFyYWdyYXBocykge1xuICAgICAgaWYgKHBhcmEucmVtb3ZlKSBjb250aW51ZTtcbiAgICAgIFxuICAgICAgY29uc3Qgc3R5bGUgPSBzdHlsZXMuZmluZChzID0+IHMuaWQgPT09IHBhcmEuc3R5bGUpO1xuICAgICAgY29uc3QgZm9ybWF0dGluZyA9IHN0eWxlPy5mb3JtYXR0aW5nIHx8IHt9O1xuICAgICAgXG4gICAgICBsZXQgYWxpZ25tZW50OiBBbGlnbm1lbnRUeXBlID0gQWxpZ25tZW50VHlwZS5MRUZUO1xuICAgICAgaWYgKGZvcm1hdHRpbmcuYWxpZ25tZW50ID09PSAnY2VudGVyJykgYWxpZ25tZW50ID0gQWxpZ25tZW50VHlwZS5DRU5URVI7XG4gICAgICBpZiAoZm9ybWF0dGluZy5hbGlnbm1lbnQgPT09ICdyaWdodCcpIGFsaWdubWVudCA9IEFsaWdubWVudFR5cGUuUklHSFQ7XG4gICAgICBpZiAoZm9ybWF0dGluZy5hbGlnbm1lbnQgPT09ICdqdXN0aWZ5JykgYWxpZ25tZW50ID0gQWxpZ25tZW50VHlwZS5KVVNUSUZJRUQ7XG4gICAgICBcbiAgICAgIGNvbnN0IGlzSGVhZGluZyA9IHN0eWxlPy53b3JkU3R5bGU/LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ2hlYWRpbmcnKTtcbiAgICAgIFxuICAgICAgY2hpbGRyZW4ucHVzaChcbiAgICAgICAgbmV3IFBhcmFncmFwaCh7XG4gICAgICAgICAgYWxpZ25tZW50LFxuICAgICAgICAgIGhlYWRpbmc6IGlzSGVhZGluZyA/IEhlYWRpbmdMZXZlbC5IRUFESU5HXzIgOiB1bmRlZmluZWQsXG4gICAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgIG5ldyBUZXh0UnVuKHtcbiAgICAgICAgICAgICAgdGV4dDogcGFyYS50ZXh0LFxuICAgICAgICAgICAgICBib2xkOiBmb3JtYXR0aW5nLmJvbGQgfHwgZmFsc2UsXG4gICAgICAgICAgICAgIGl0YWxpY3M6IGZvcm1hdHRpbmcuaXRhbGljIHx8IGZhbHNlLFxuICAgICAgICAgICAgICB1bmRlcmxpbmU6IGZvcm1hdHRpbmcudW5kZXJsaW5lID8ge30gOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgIHNpemU6IGZvcm1hdHRpbmcuZm9udFNpemUgPyBmb3JtYXR0aW5nLmZvbnRTaXplICogMiA6IDI0LFxuICAgICAgICAgICAgICBjb2xvcjogZm9ybWF0dGluZy5jb2xvcj8ucmVwbGFjZSgnIycsICcnKSB8fCAnMDAwMDAwJ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICBdLFxuICAgICAgICAgIHNwYWNpbmc6IHsgYWZ0ZXI6IDIwMCB9XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gbmV3IERvY3VtZW50KHtcbiAgICAgIHNlY3Rpb25zOiBbe1xuICAgICAgICBwcm9wZXJ0aWVzOiB7fSxcbiAgICAgICAgY2hpbGRyZW5cbiAgICAgIH1dXG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGFwcGx5UG9zdFByb2Nlc3NpbmcocGFyYWdyYXBoczogUHJvY2Vzc2VkUGFyYWdyYXBoW10sIG9wdGlvbnM6IFBvc3RQcm9jZXNzaW5nT3B0aW9ucykge1xuICAgIHBhcmFncmFwaHMuZm9yRWFjaChwYXJhID0+IHtcbiAgICAgIGlmIChwYXJhLnJlbW92ZSkgcmV0dXJuO1xuICAgICAgXG4gICAgICBsZXQgdGV4dCA9IHBhcmEudGV4dDtcbiAgICAgIFxuICAgICAgLy8gUmVtb3ZlIHF1ZXN0aW9uIG51bWJlcnMgaWYgcmVxdWVzdGVkXG4gICAgICBpZiAob3B0aW9ucy5yZW1vdmVRdWVzdGlvbk51bWJlcnMgJiYgKHBhcmEuc3R5bGUgPT09ICdlbnVuY2lhZG8nIHx8IHBhcmEuc3R5bGUgPT09ICdxdWVzdGFvJykpIHtcbiAgICAgICAgLy8gUmVtb3ZlIHBhdHRlcm5zIGxpa2UgXCIxLlwiLCBcIjEpXCIsIFwiMDEuXCIsIFwiUTE6XCIsIGV0Yy5cbiAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvXihcXGQrW1xcLlxcKV1cXHMqfFFcXGQrOj9cXHMqfFxcZCtcXHMqLVxccyopL2ksICcnKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gUmVtb3ZlIGFsdGVybmF0aXZlIGxldHRlcnMgaWYgcmVxdWVzdGVkXG4gICAgICBpZiAob3B0aW9ucy5yZW1vdmVBbHRlcm5hdGl2ZUxldHRlcnMgJiYgcGFyYS5zdHlsZSA9PT0gJ2FsdGVybmF0aXZhJykge1xuICAgICAgICAvLyBSZW1vdmUgcGF0dGVybnMgbGlrZSBcImEpXCIsIFwiQS5cIiwgXCIoYSlcIiwgXCJbQV1cIiwgZXRjLlxuICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9eKFxcKD9bYS1lQS1FXVtcXC5cXCldXFwpP3xcXFtbYS1lQS1FXVxcXSlcXHMqL2ksICcnKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQXBwbHkgY3VzdG9tIHJlbW92YWxzXG4gICAgICBpZiAob3B0aW9ucy5jdXN0b21SZW1vdmFscyAmJiBvcHRpb25zLmN1c3RvbVJlbW92YWxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgb3B0aW9ucy5jdXN0b21SZW1vdmFscy5mb3JFYWNoKHBhdHRlcm4gPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZWdleCA9IG5ldyBSZWdFeHAocGF0dGVybiwgJ2dpJyk7XG4gICAgICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKHJlZ2V4LCAnJyk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gSWYgcmVnZXggaXMgaW52YWxpZCwgdHJ5IGxpdGVyYWwgcmVwbGFjZW1lbnRcbiAgICAgICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UobmV3IFJlZ0V4cChwYXR0ZXJuLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCAnXFxcXCQmJyksICdnaScpLCAnJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcGFyYS50ZXh0ID0gdGV4dC50cmltKCk7XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGNyZWF0ZVNhbml0aXplZERvY3VtZW50Rm9ySW5EZXNpZ24ocHJvY2Vzc2VkUGFyYWdyYXBoczogUHJvY2Vzc2VkUGFyYWdyYXBoW10sIHN0eWxlczogU3R5bGVbXSwgYm9va05hbWU6IHN0cmluZyk6IERvY3VtZW50IHtcbiAgICBjb25zdCBjaGlsZHJlbjogUGFyYWdyYXBoW10gPSBbXTtcbiAgICBcbiAgICAvLyBDcmVhdGUgYSBzdHlsZSBtYXAgdG8gZW5zdXJlIGNvbnNpc3RlbnQgbmFtaW5nIGZvciBJbkRlc2lnblxuICAgIGNvbnN0IHN0eWxlTWFwID0gbmV3IE1hcDxzdHJpbmcsIHN0cmluZz4oKTtcbiAgICBzdHlsZXMuZm9yRWFjaChzdHlsZSA9PiB7XG4gICAgICAvLyBVc2UgdGhlIFdvcmQgc3R5bGUgbmFtZSBmb3IgSW5EZXNpZ24gY29uc2lzdGVuY3lcbiAgICAgIC8vIFRoaXMgcHJldmVudHMgZHVwbGljYXRlIHN0eWxlcyB3aXRoIHNhbWUgbmFtZXNcbiAgICAgIHN0eWxlTWFwLnNldChzdHlsZS5pZCwgc3R5bGUud29yZFN0eWxlKTtcbiAgICB9KTtcbiAgICBcbiAgICAvLyBBZGQgZG9jdW1lbnQgaGVhZGVyIHdpdGggc3R5bGUgZGVmaW5pdGlvbnMgZm9yIEluRGVzaWduXG4gICAgY2hpbGRyZW4ucHVzaChcbiAgICAgIG5ldyBQYXJhZ3JhcGgoe1xuICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgIG5ldyBUZXh0UnVuKHtcbiAgICAgICAgICAgIHRleHQ6IGBbSU5ERVNJR05fU1RZTEVTX1NUQVJUXWAsXG4gICAgICAgICAgICBzaXplOiAyMFxuICAgICAgICAgIH0pXG4gICAgICAgIF1cbiAgICAgIH0pXG4gICAgKTtcbiAgICBcbiAgICAvLyBMaXN0IGFsbCBzdHlsZXMgZm9yIEluRGVzaWduIHRvIHJlY29nbml6ZVxuICAgIHN0eWxlcy5mb3JFYWNoKHN0eWxlID0+IHtcbiAgICAgIGNoaWxkcmVuLnB1c2goXG4gICAgICAgIG5ldyBQYXJhZ3JhcGgoe1xuICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICBuZXcgVGV4dFJ1bih7XG4gICAgICAgICAgICAgIHRleHQ6IGBbU1RZTEVfREVGXSAke3N0eWxlLndvcmRTdHlsZX0gPSAke3N0eWxlLm1hcmtlcn1gLFxuICAgICAgICAgICAgICBzaXplOiAyMFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICBdXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH0pO1xuICAgIFxuICAgIGNoaWxkcmVuLnB1c2goXG4gICAgICBuZXcgUGFyYWdyYXBoKHtcbiAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICBuZXcgVGV4dFJ1bih7XG4gICAgICAgICAgICB0ZXh0OiBgW0lOREVTSUdOX1NUWUxFU19FTkRdYCxcbiAgICAgICAgICAgIHNpemU6IDIwXG4gICAgICAgICAgfSlcbiAgICAgICAgXSxcbiAgICAgICAgc3BhY2luZzogeyBhZnRlcjogNDAwIH1cbiAgICAgIH0pXG4gICAgKTtcbiAgICBcbiAgICAvLyBQcm9jZXNzIHBhcmFncmFwaHMgd2l0aCBjb25zaXN0ZW50IHN0eWxlIG5hbWluZ1xuICAgIGZvciAoY29uc3QgcGFyYSBvZiBwcm9jZXNzZWRQYXJhZ3JhcGhzKSB7XG4gICAgICBpZiAocGFyYS5yZW1vdmUpIGNvbnRpbnVlO1xuICAgICAgXG4gICAgICBjb25zdCBzdHlsZSA9IHN0eWxlcy5maW5kKHMgPT4gcy5pZCA9PT0gcGFyYS5zdHlsZSk7XG4gICAgICBjb25zdCBzdHlsZU5hbWUgPSBzdHlsZU1hcC5nZXQocGFyYS5zdHlsZSB8fCAnJykgfHwgJ05vcm1hbCc7XG4gICAgICBcbiAgICAgIC8vIFVzZSBjb25zaXN0ZW50IHN0eWxlIG5hbWluZyBmb3IgSW5EZXNpZ25cbiAgICAgIGNoaWxkcmVuLnB1c2goXG4gICAgICAgIG5ldyBQYXJhZ3JhcGgoe1xuICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICBuZXcgVGV4dFJ1bih7XG4gICAgICAgICAgICAgIHRleHQ6IGBbJHtzdHlsZU5hbWV9XSAke3BhcmEudGV4dH1gLFxuICAgICAgICAgICAgICBzaXplOiAyNFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICBdLFxuICAgICAgICAgIHNwYWNpbmc6IHsgYWZ0ZXI6IDEyMCB9XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gbmV3IERvY3VtZW50KHtcbiAgICAgIHNlY3Rpb25zOiBbe1xuICAgICAgICBwcm9wZXJ0aWVzOiB7fSxcbiAgICAgICAgY2hpbGRyZW5cbiAgICAgIH1dXG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGZvcm1hdEZpbGVTaXplKGJ5dGVzOiBudW1iZXIpOiBzdHJpbmcge1xuICAgIGlmIChieXRlcyA8IDEwMjQpIHJldHVybiBieXRlcyArICcgQic7XG4gICAgaWYgKGJ5dGVzIDwgMTAyNCAqIDEwMjQpIHJldHVybiAoYnl0ZXMgLyAxMDI0KS50b0ZpeGVkKDEpICsgJyBLQic7XG4gICAgcmV0dXJuIChieXRlcyAvICgxMDI0ICogMTAyNCkpLnRvRml4ZWQoMSkgKyAnIE1CJztcbiAgfVxufSJdLCJuYW1lcyI6WyJtYW1tb3RoIiwiRG9jdW1lbnQiLCJQYWNrZXIiLCJQYXJhZ3JhcGgiLCJUZXh0UnVuIiwiSGVhZGluZ0xldmVsIiwiQWxpZ25tZW50VHlwZSIsIkpTWmlwIiwiRG9jdW1lbnRQcm9jZXNzb3IiLCJwcm9jZXNzRG9jdW1lbnQiLCJmaWxlIiwiYm9va05hbWUiLCJzdHlsZXMiLCJ0cmFuc2l0aW9ucyIsInJlbW92YWxQcm9tcHRzIiwicG9zdFByb2Nlc3NpbmciLCJvblByb2dyZXNzIiwic3RhcnRUaW1lIiwiRGF0ZSIsIm5vdyIsInppcCIsImFycmF5QnVmZmVyIiwicmVzdWx0IiwiZXh0cmFjdFJhd1RleHQiLCJ0ZXh0IiwidmFsdWUiLCJwYXJhZ3JhcGhzIiwic3BsaXQiLCJmaWx0ZXIiLCJwIiwidHJpbSIsImxlbmd0aCIsInByb2Nlc3NlZFBhcmFncmFwaHMiLCJwcm9jZXNzUGFyYWdyYXBoc09wdGltaXplZCIsImFwcGx5UG9zdFByb2Nlc3NpbmciLCJkb2MiLCJjcmVhdGVTdHlsZWREb2N1bWVudCIsInNhbml0aXplZERvYyIsImNyZWF0ZVNhbml0aXplZERvY3VtZW50Rm9ySW5EZXNpZ24iLCJtYWluQmxvYiIsInNhbml0aXplZEJsb2IiLCJQcm9taXNlIiwiYWxsIiwidG9CbG9iIiwidGltZXN0YW1wIiwidG9JU09TdHJpbmciLCJyZXBsYWNlIiwiZm9sZGVyTmFtZSIsImZvbGRlciIsInppcEJsb2IiLCJnZW5lcmF0ZUFzeW5jIiwidHlwZSIsInByb2Nlc3NpbmdUaW1lIiwiTWF0aCIsInJvdW5kIiwic3VjY2VzcyIsImRvY3VtZW50QmxvYiIsInN0YXRzIiwidG90YWxQYWdlcyIsImNlaWwiLCJ0b3RhbFBhcmFncmFwaHMiLCJxdWVzdGlvbnNQcm9jZXNzZWQiLCJzdHlsZSIsImFwaUNhbGxzIiwiZXN0aW1hdGVkQ29zdFVTRCIsImZpbGVzIiwibmFtZSIsInNpemUiLCJmb3JtYXRGaWxlU2l6ZSIsInBhdGgiLCJmbG9vciIsImVycm9yIiwiY29uc29sZSIsIkVycm9yIiwibWVzc2FnZSIsImJhdGNoU2l6ZSIsImkiLCJiYXRjaCIsInNsaWNlIiwibWluIiwiY29udGV4dEJhdGNoIiwicHJldmlvdXNDb250ZXh0IiwibWF4IiwicHJvbXB0IiwiYnVpbGRPcHRpbWl6ZWRQcm9tcHQiLCJzeXN0ZW1Qcm9tcHQiLCJhcGlSZXNwb25zZSIsImZldGNoIiwibWV0aG9kIiwiaGVhZGVycyIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwidXNlcklkIiwib2siLCJqc29uIiwiY3JlZGl0c1JlbWFpbmluZyIsInBsYW4iLCJtYXJrZWRDb250ZW50Iiwiam9pbiIsInBhcnNlZCIsInBhcnNlTWFya2VkQ29udGVudCIsInB1c2giLCJwcm9ncmVzcyIsImZvckVhY2giLCJyZW1vdmUiLCJzdGFydEluZGV4IiwiY29udGV4dE9mZnNldCIsImFjdHVhbFN0YXJ0IiwiYWN0dWFsRW5kIiwiZWxlbWVudFR5cGUiLCJtYXJrZXIiLCJyZW1vdmFsIiwic3RhcnRNYXJrZXIiLCJlbmRNYXJrZXIiLCJwYXJhIiwiaW5kZXgiLCJjb250ZW50IiwibGluZXMiLCJsaW5lIiwicGFyYU1hdGNoIiwibWF0Y2giLCJjbGVhbkxpbmUiLCJtYXRjaGVkIiwiaW5jbHVkZXMiLCJleHRyYWN0VGV4dCIsInRhZ1JlZ2V4IiwiUmVnRXhwIiwiaWQiLCJub3JtYWxNYXRjaCIsImNsZWFuVGV4dCIsImNoaWxkcmVuIiwiYWxpZ25tZW50IiwiQ0VOVEVSIiwiYm9sZCIsImNvbG9yIiwic3BhY2luZyIsImFmdGVyIiwiZm9ybWF0dGluZyIsImZpbmQiLCJzIiwiTEVGVCIsIlJJR0hUIiwiSlVTVElGSUVEIiwiaXNIZWFkaW5nIiwid29yZFN0eWxlIiwidG9Mb3dlckNhc2UiLCJoZWFkaW5nIiwiSEVBRElOR18yIiwidW5kZWZpbmVkIiwiaXRhbGljcyIsIml0YWxpYyIsInVuZGVybGluZSIsImZvbnRTaXplIiwic2VjdGlvbnMiLCJwcm9wZXJ0aWVzIiwib3B0aW9ucyIsInJlbW92ZVF1ZXN0aW9uTnVtYmVycyIsInJlbW92ZUFsdGVybmF0aXZlTGV0dGVycyIsImN1c3RvbVJlbW92YWxzIiwicGF0dGVybiIsInJlZ2V4IiwiZSIsInN0eWxlTWFwIiwiTWFwIiwic2V0Iiwic3R5bGVOYW1lIiwiZ2V0IiwiYnl0ZXMiLCJ0b0ZpeGVkIiwiY29uc3RydWN0b3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/documentProcessor.ts\n"));

/***/ })

});