"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/styler/page",{

/***/ "(app-pages-browser)/./src/utils/documentProcessor.ts":
/*!****************************************!*\
  !*** ./src/utils/documentProcessor.ts ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DocumentProcessor: function() { return /* binding */ DocumentProcessor; }\n/* harmony export */ });\n/* harmony import */ var mammoth__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mammoth */ \"(app-pages-browser)/./node_modules/mammoth/lib/index.js\");\n/* harmony import */ var docx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! docx */ \"(app-pages-browser)/./node_modules/docx/build/index.mjs\");\n/* harmony import */ var jszip__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! jszip */ \"(app-pages-browser)/./node_modules/jszip/dist/jszip.min.js\");\n/* harmony import */ var jszip__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(jszip__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\nclass DocumentProcessor {\n    async processDocument(file, bookName, styles, transitions, removalPrompts, postProcessing, onProgress) {\n        const startTime = Date.now();\n        try {\n            var _zip_folder, _zip_folder1;\n            onProgress === null || onProgress === void 0 ? void 0 : onProgress(5, \"Lendo documento...\");\n            // Read document content\n            const arrayBuffer = await file.arrayBuffer();\n            const result = await mammoth__WEBPACK_IMPORTED_MODULE_0__.extractRawText({\n                arrayBuffer\n            });\n            const text = result.value;\n            // Extract paragraphs\n            const paragraphs = text.split(\"\\n\").filter((p)=>p.trim().length > 0);\n            onProgress === null || onProgress === void 0 ? void 0 : onProgress(20, \"Analisando estrutura do documento...\");\n            // OPTIMIZED BATCH PROCESSING - Fix redundancy issue\n            const processedParagraphs = await this.processParagraphsOptimized(paragraphs, styles, removalPrompts, onProgress);\n            // Apply post-processing if requested\n            if (postProcessing) {\n                onProgress === null || onProgress === void 0 ? void 0 : onProgress(65, \"Aplicando p\\xf3s-processamento...\");\n                this.applyPostProcessing(processedParagraphs, postProcessing);\n            }\n            onProgress === null || onProgress === void 0 ? void 0 : onProgress(70, \"Aplicando estilos e formata\\xe7\\xe3o...\");\n            // Create styled document\n            const doc = this.createStyledDocument(processedParagraphs, styles, bookName);\n            onProgress === null || onProgress === void 0 ? void 0 : onProgress(85, \"Criando arquivo sanitizado para InDesign...\");\n            // Create sanitized version for InDesign with consistent style naming\n            const sanitizedDoc = this.createSanitizedDocumentForInDesign(processedParagraphs, styles, bookName);\n            onProgress === null || onProgress === void 0 ? void 0 : onProgress(90, \"Gerando arquivos finais...\");\n            // Generate blobs\n            const [mainBlob, sanitizedBlob] = await Promise.all([\n                docx__WEBPACK_IMPORTED_MODULE_1__.Packer.toBlob(doc),\n                docx__WEBPACK_IMPORTED_MODULE_1__.Packer.toBlob(sanitizedDoc)\n            ]);\n            // Create ZIP with all files\n            const zip = new (jszip__WEBPACK_IMPORTED_MODULE_2___default())();\n            const timestamp = new Date().toISOString().replace(/[:.]/g, \"-\");\n            const folderName = \"\".concat(bookName, \"_\").concat(timestamp);\n            (_zip_folder = zip.folder(folderName)) === null || _zip_folder === void 0 ? void 0 : _zip_folder.file(\"completo.docx\", mainBlob);\n            (_zip_folder1 = zip.folder(folderName)) === null || _zip_folder1 === void 0 ? void 0 : _zip_folder1.file(\"completo_pronto_para_indesign.docx\", sanitizedBlob);\n            const zipBlob = await zip.generateAsync({\n                type: \"blob\"\n            });\n            const processingTime = Math.round((Date.now() - startTime) / 1000);\n            onProgress === null || onProgress === void 0 ? void 0 : onProgress(100, \"Processamento conclu\\xeddo!\");\n            return {\n                success: true,\n                documentBlob: mainBlob,\n                zipBlob,\n                stats: {\n                    totalPages: Math.ceil(paragraphs.length / 30),\n                    totalParagraphs: paragraphs.length,\n                    questionsProcessed: processedParagraphs.filter((p)=>p.style === \"enunciado\" || p.style === \"questao\").length,\n                    apiCalls: Math.ceil(paragraphs.length / 25),\n                    estimatedCostUSD: Math.ceil(paragraphs.length / 25) * 0.002\n                },\n                files: [\n                    {\n                        name: \"completo.docx\",\n                        size: this.formatFileSize(mainBlob.size),\n                        path: \"completo.docx\"\n                    },\n                    {\n                        name: \"completo_pronto_para_indesign.docx\",\n                        size: this.formatFileSize(sanitizedBlob.size),\n                        path: \"completo_pronto_para_indesign.docx\"\n                    }\n                ],\n                processingTime: \"\".concat(Math.floor(processingTime / 60), \"m \").concat(processingTime % 60, \"s\")\n            };\n        } catch (error) {\n            console.error(\"Erro no processamento:\", error);\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : \"Erro desconhecido no processamento\"\n            };\n        }\n    }\n    async processParagraphsOptimized(paragraphs, styles, removalPrompts, onProgress) {\n        const processedParagraphs = [];\n        let apiCalls = 0;\n        // OPTIMIZED: Balance between context and accuracy\n        // 20-25 paragraphs gives enough context without overwhelming the AI\n        const batchSize = 25; // Optimal for accuracy with context\n        for(let i = 0; i < paragraphs.length; i += batchSize){\n            const batch = paragraphs.slice(i, Math.min(i + batchSize, paragraphs.length));\n            // Add some context from previous batch for continuity (last 3 paragraphs)\n            let contextBatch = batch;\n            if (i > 0 && processedParagraphs.length >= 3) {\n                const previousContext = paragraphs.slice(Math.max(0, i - 3), i);\n                contextBatch = [\n                    ...previousContext,\n                    ...batch\n                ];\n            }\n            // Build context-aware prompt\n            const prompt = this.buildOptimizedPrompt(contextBatch, styles, removalPrompts, i, paragraphs.length, i > 0 ? 3 : 0);\n            try {\n                const response = await this.openai.chat.completions.create({\n                    model: \"gpt-4o-mini\",\n                    messages: [\n                        {\n                            role: \"system\",\n                            content: \"Voc\\xea \\xe9 um assistente especializado em formatar documentos educacionais.\\nAnalise o texto e marque CADA par\\xe1grafo com tags XML apropriadas.\\nIMPORTANTE: \\n- Marque TODOS os par\\xe1grafos, mesmo que n\\xe3o correspondam a nenhum estilo espec\\xedfico (use <normal> para texto comum)\\n- Mantenha a ordem exata dos par\\xe1grafos\\n- Para remo\\xe7\\xf5es, use as tags de in\\xedcio e fim especificadas\"\n                        },\n                        {\n                            role: \"user\",\n                            content: prompt\n                        }\n                    ],\n                    temperature: 0.2,\n                    max_tokens: 8000\n                });\n                apiCalls++;\n                const markedContent = response.choices[0].message.content || \"\";\n                // Parse marked content\n                const parsed = this.parseMarkedContent(markedContent, styles);\n                processedParagraphs.push(...parsed);\n                const progress = 20 + (i + batchSize) / paragraphs.length * 50;\n                onProgress === null || onProgress === void 0 ? void 0 : onProgress(Math.min(progress, 70), \"Processando \".concat(Math.min(i + batchSize, paragraphs.length), \"/\").concat(paragraphs.length, \" par\\xe1grafos...\"));\n            } catch (error) {\n                console.error(\"Erro ao processar batch:\", error);\n                // Add unprocessed paragraphs as normal text\n                batch.forEach((text)=>{\n                    processedParagraphs.push({\n                        text,\n                        style: \"normal\",\n                        remove: false,\n                        type: \"text\"\n                    });\n                });\n            }\n        }\n        return processedParagraphs;\n    }\n    buildOptimizedPrompt(batch, styles, removalPrompts, startIndex, totalParagraphs) {\n        let contextOffset = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 0;\n        const actualStart = startIndex - contextOffset + 1;\n        const actualEnd = Math.min(startIndex + batch.length - contextOffset, totalParagraphs);\n        let prompt = \"Contexto: Analisando par\\xe1grafos \".concat(actualStart, \" a \").concat(actualEnd, \" de um total de \").concat(totalParagraphs, \".\\n\");\n        if (contextOffset > 0) {\n            prompt += \"Nota: Os primeiros \".concat(contextOffset, \" par\\xe1grafos s\\xe3o contexto da batch anterior (j\\xe1 processados).\\n\");\n        }\n        prompt += \"\\n\";\n        prompt += \"ESTILOS DISPON\\xcdVEIS:\\n\";\n        styles.forEach((style)=>{\n            if (style.elementType === \"text\") {\n                prompt += \"<\".concat(style.marker.replace(/[\\[\\]]/g, \"\"), \"> - \").concat(style.prompt, \"\\n\");\n            }\n        });\n        prompt += \"\\nREMO\\xc7\\xd5ES:\\n\";\n        removalPrompts.forEach((removal)=>{\n            prompt += \"\".concat(removal.startMarker, \" e \").concat(removal.endMarker, \" - \").concat(removal.prompt, \"\\n\");\n        });\n        prompt += \"\\nTEXTO PARA ANALISAR:\\n\";\n        batch.forEach((para, index)=>{\n            prompt += \"[P\".concat(startIndex + index + 1, \"] \").concat(para, \"\\n\");\n        });\n        prompt += \"\\nRETORNE o texto marcado mantendo a numera\\xe7\\xe3o [P#] e aplicando as tags apropriadas.\\nExemplo de sa\\xedda:\\n[P1] <TITULO_SIMULADO>Simulado 1</TITULO_SIMULADO>\\n[P2] <normal>Texto comum sem estilo espec\\xedfico</normal>\\n[P3] <ENUNCIADO>1. Qual \\xe9 a capital do Brasil?</ENUNCIADO>\\n[P4] <ALTERNATIVA>a) S\\xe3o Paulo</ALTERNATIVA>\";\n        return prompt;\n    }\n    parseMarkedContent(content, styles) {\n        const parsed = [];\n        const lines = content.split(\"\\n\");\n        for (const line of lines){\n            if (!line.trim()) continue;\n            // Extract paragraph number if present\n            const paraMatch = line.match(/\\[P\\d+\\]/);\n            const cleanLine = paraMatch ? line.replace(paraMatch[0], \"\").trim() : line.trim();\n            let matched = false;\n            // Check for removal markers\n            if (cleanLine.includes(\"REMOVE\") && (cleanLine.includes(\"START\") || cleanLine.includes(\"END\"))) {\n                parsed.push({\n                    text: this.extractText(cleanLine),\n                    style: null,\n                    remove: true,\n                    type: \"text\"\n                });\n                matched = true;\n            } else {\n                // Check for style markers\n                for (const style of styles){\n                    const marker = style.marker.replace(/[\\[\\]]/g, \"\");\n                    const tagRegex = new RegExp(\"<\".concat(marker, \">(.*?)</\").concat(marker, \">\"), \"i\");\n                    const match = cleanLine.match(tagRegex);\n                    if (match) {\n                        parsed.push({\n                            text: match[1].trim(),\n                            style: style.id,\n                            remove: false,\n                            type: style.elementType\n                        });\n                        matched = true;\n                        break;\n                    }\n                }\n            }\n            // If no match, check for normal tag or add as normal text\n            if (!matched) {\n                const normalMatch = cleanLine.match(/<normal>(.*?)<\\/normal>/i);\n                if (normalMatch) {\n                    parsed.push({\n                        text: normalMatch[1].trim(),\n                        style: \"normal\",\n                        remove: false,\n                        type: \"text\"\n                    });\n                } else {\n                    const cleanText = this.extractText(cleanLine);\n                    if (cleanText) {\n                        parsed.push({\n                            text: cleanText,\n                            style: \"normal\",\n                            remove: false,\n                            type: \"text\"\n                        });\n                    }\n                }\n            }\n        }\n        return parsed;\n    }\n    extractText(line) {\n        return line.replace(/<[^>]*>/g, \"\").replace(/\\[P\\d+\\]/, \"\").trim();\n    }\n    createStyledDocument(processedParagraphs, styles, bookName) {\n        const children = [];\n        // Add title\n        children.push(new docx__WEBPACK_IMPORTED_MODULE_1__.Paragraph({\n            alignment: docx__WEBPACK_IMPORTED_MODULE_1__.AlignmentType.CENTER,\n            children: [\n                new docx__WEBPACK_IMPORTED_MODULE_1__.TextRun({\n                    text: bookName,\n                    bold: true,\n                    size: 32,\n                    color: \"1e40af\"\n                })\n            ],\n            spacing: {\n                after: 400\n            }\n        }));\n        // Process paragraphs\n        for (const para of processedParagraphs){\n            var _style_wordStyle, _formatting_color;\n            if (para.remove) continue;\n            const style = styles.find((s)=>s.id === para.style);\n            const formatting = (style === null || style === void 0 ? void 0 : style.formatting) || {};\n            let alignment = docx__WEBPACK_IMPORTED_MODULE_1__.AlignmentType.LEFT;\n            if (formatting.alignment === \"center\") alignment = docx__WEBPACK_IMPORTED_MODULE_1__.AlignmentType.CENTER;\n            if (formatting.alignment === \"right\") alignment = docx__WEBPACK_IMPORTED_MODULE_1__.AlignmentType.RIGHT;\n            if (formatting.alignment === \"justify\") alignment = docx__WEBPACK_IMPORTED_MODULE_1__.AlignmentType.JUSTIFIED;\n            const isHeading = style === null || style === void 0 ? void 0 : (_style_wordStyle = style.wordStyle) === null || _style_wordStyle === void 0 ? void 0 : _style_wordStyle.toLowerCase().includes(\"heading\");\n            children.push(new docx__WEBPACK_IMPORTED_MODULE_1__.Paragraph({\n                alignment,\n                heading: isHeading ? docx__WEBPACK_IMPORTED_MODULE_1__.HeadingLevel.HEADING_2 : undefined,\n                children: [\n                    new docx__WEBPACK_IMPORTED_MODULE_1__.TextRun({\n                        text: para.text,\n                        bold: formatting.bold || false,\n                        italics: formatting.italic || false,\n                        underline: formatting.underline ? {} : undefined,\n                        size: formatting.fontSize ? formatting.fontSize * 2 : 24,\n                        color: ((_formatting_color = formatting.color) === null || _formatting_color === void 0 ? void 0 : _formatting_color.replace(\"#\", \"\")) || \"000000\"\n                    })\n                ],\n                spacing: {\n                    after: 200\n                }\n            }));\n        }\n        return new docx__WEBPACK_IMPORTED_MODULE_1__.Document({\n            sections: [\n                {\n                    properties: {},\n                    children\n                }\n            ]\n        });\n    }\n    applyPostProcessing(paragraphs, options) {\n        paragraphs.forEach((para)=>{\n            if (para.remove) return;\n            let text = para.text;\n            // Remove question numbers if requested\n            if (options.removeQuestionNumbers && (para.style === \"enunciado\" || para.style === \"questao\")) {\n                // Remove patterns like \"1.\", \"1)\", \"01.\", \"Q1:\", etc.\n                text = text.replace(/^(\\d+[\\.\\)]\\s*|Q\\d+:?\\s*|\\d+\\s*-\\s*)/i, \"\");\n            }\n            // Remove alternative letters if requested\n            if (options.removeAlternativeLetters && para.style === \"alternativa\") {\n                // Remove patterns like \"a)\", \"A.\", \"(a)\", \"[A]\", etc.\n                text = text.replace(/^(\\(?[a-eA-E][\\.\\)]\\)?|\\[[a-eA-E]\\])\\s*/i, \"\");\n            }\n            // Apply custom removals\n            if (options.customRemovals && options.customRemovals.length > 0) {\n                options.customRemovals.forEach((pattern)=>{\n                    try {\n                        const regex = new RegExp(pattern, \"gi\");\n                        text = text.replace(regex, \"\");\n                    } catch (e) {\n                        // If regex is invalid, try literal replacement\n                        text = text.replace(new RegExp(pattern.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\"), \"gi\"), \"\");\n                    }\n                });\n            }\n            para.text = text.trim();\n        });\n    }\n    createSanitizedDocumentForInDesign(processedParagraphs, styles, bookName) {\n        const children = [];\n        // Create a style map to ensure consistent naming for InDesign\n        const styleMap = new Map();\n        styles.forEach((style)=>{\n            // Use the Word style name for InDesign consistency\n            // This prevents duplicate styles with same names\n            styleMap.set(style.id, style.wordStyle);\n        });\n        // Add document header with style definitions for InDesign\n        children.push(new docx__WEBPACK_IMPORTED_MODULE_1__.Paragraph({\n            children: [\n                new docx__WEBPACK_IMPORTED_MODULE_1__.TextRun({\n                    text: \"[INDESIGN_STYLES_START]\",\n                    size: 20\n                })\n            ]\n        }));\n        // List all styles for InDesign to recognize\n        styles.forEach((style)=>{\n            children.push(new docx__WEBPACK_IMPORTED_MODULE_1__.Paragraph({\n                children: [\n                    new docx__WEBPACK_IMPORTED_MODULE_1__.TextRun({\n                        text: \"[STYLE_DEF] \".concat(style.wordStyle, \" = \").concat(style.marker),\n                        size: 20\n                    })\n                ]\n            }));\n        });\n        children.push(new docx__WEBPACK_IMPORTED_MODULE_1__.Paragraph({\n            children: [\n                new docx__WEBPACK_IMPORTED_MODULE_1__.TextRun({\n                    text: \"[INDESIGN_STYLES_END]\",\n                    size: 20\n                })\n            ],\n            spacing: {\n                after: 400\n            }\n        }));\n        // Process paragraphs with consistent style naming\n        for (const para of processedParagraphs){\n            if (para.remove) continue;\n            const style = styles.find((s)=>s.id === para.style);\n            const styleName = styleMap.get(para.style || \"\") || \"Normal\";\n            // Use consistent style naming for InDesign\n            children.push(new docx__WEBPACK_IMPORTED_MODULE_1__.Paragraph({\n                children: [\n                    new docx__WEBPACK_IMPORTED_MODULE_1__.TextRun({\n                        text: \"[\".concat(styleName, \"] \").concat(para.text),\n                        size: 24\n                    })\n                ],\n                spacing: {\n                    after: 120\n                }\n            }));\n        }\n        return new docx__WEBPACK_IMPORTED_MODULE_1__.Document({\n            sections: [\n                {\n                    properties: {},\n                    children\n                }\n            ]\n        });\n    }\n    formatFileSize(bytes) {\n        if (bytes < 1024) return bytes + \" B\";\n        if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + \" KB\";\n        return (bytes / (1024 * 1024)).toFixed(1) + \" MB\";\n    }\n    constructor(){\n    // API key is now handled server-side\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy9kb2N1bWVudFByb2Nlc3Nvci50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUE4QjtBQUM0RztBQUNoSDtBQXVFbkIsTUFBTVE7SUFLWCxNQUFNQyxnQkFDSkMsSUFBVSxFQUNWQyxRQUFnQixFQUNoQkMsTUFBZSxFQUNmQyxXQUF5QixFQUN6QkMsY0FBK0IsRUFDL0JDLGNBQXNDLEVBQ3RDQyxVQUF3RCxFQUM3QjtRQUMzQixNQUFNQyxZQUFZQyxLQUFLQyxHQUFHO1FBRTFCLElBQUk7Z0JBa0RGQyxhQUNBQTtZQWxEQUosdUJBQUFBLGlDQUFBQSxXQUFhLEdBQUc7WUFFaEIsd0JBQXdCO1lBQ3hCLE1BQU1LLGNBQWMsTUFBTVgsS0FBS1csV0FBVztZQUMxQyxNQUFNQyxTQUFTLE1BQU10QixtREFBc0IsQ0FBQztnQkFBRXFCO1lBQVk7WUFDMUQsTUFBTUcsT0FBT0YsT0FBT0csS0FBSztZQUV6QixxQkFBcUI7WUFDckIsTUFBTUMsYUFBYUYsS0FBS0csS0FBSyxDQUFDLE1BQU1DLE1BQU0sQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRUMsSUFBSSxHQUFHQyxNQUFNLEdBQUc7WUFFbEVmLHVCQUFBQSxpQ0FBQUEsV0FBYSxJQUFJO1lBRWpCLG9EQUFvRDtZQUNwRCxNQUFNZ0Isc0JBQXNCLE1BQU0sSUFBSSxDQUFDQywwQkFBMEIsQ0FDL0RQLFlBQ0FkLFFBQ0FFLGdCQUNBRTtZQUdGLHFDQUFxQztZQUNyQyxJQUFJRCxnQkFBZ0I7Z0JBQ2xCQyx1QkFBQUEsaUNBQUFBLFdBQWEsSUFBSTtnQkFDakIsSUFBSSxDQUFDa0IsbUJBQW1CLENBQUNGLHFCQUFxQmpCO1lBQ2hEO1lBRUFDLHVCQUFBQSxpQ0FBQUEsV0FBYSxJQUFJO1lBRWpCLHlCQUF5QjtZQUN6QixNQUFNbUIsTUFBTSxJQUFJLENBQUNDLG9CQUFvQixDQUFDSixxQkFBcUJwQixRQUFRRDtZQUVuRUssdUJBQUFBLGlDQUFBQSxXQUFhLElBQUk7WUFF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QUVDLE9BQU87WUFBSTtRQUN4QjtRQUdGLGtEQUFrRDtRQUNsRCxLQUFLLE1BQU1yQixRQUFRakYsb0JBQXFCO1lBQ3RDLElBQUlpRixLQUFLVixNQUFNLEVBQUU7WUFFakIsTUFBTXpDLFFBQVFsRCxPQUFPNEgsSUFBSSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFWixFQUFFLEtBQUtaLEtBQUtuRCxLQUFLO1lBQ2xELE1BQU1xRyxZQUFZSCxTQUFTSSxHQUFHLENBQUNuRCxLQUFLbkQsS0FBSyxJQUFJLE9BQU87WUFFcEQsMkNBQTJDO1lBQzNDa0UsU0FBUzVCLElBQUksQ0FDWCxJQUFJakcsMkNBQVNBLENBQUM7Z0JBQ1o2SCxVQUFVO29CQUNSLElBQUk1SCx5Q0FBT0EsQ0FBQzt3QkFDVm9CLE1BQU0sSUFBa0J5RixPQUFka0QsV0FBVSxNQUFjLE9BQVZsRCxLQUFLekYsSUFBSTt3QkFDakMyQyxNQUFNO29CQUNSO2lCQUNEO2dCQUNEa0UsU0FBUztvQkFBRUMsT0FBTztnQkFBSTtZQUN4QjtRQUVKO1FBRUEsT0FBTyxJQUFJckksMENBQVFBLENBQUM7WUFDbEJzSixVQUFVO2dCQUFDO29CQUNUQyxZQUFZLENBQUM7b0JBQ2J4QjtnQkFDRjthQUFFO1FBQ0o7SUFDRjtJQUVRNUQsZUFBZWlHLEtBQWEsRUFBVTtRQUM1QyxJQUFJQSxRQUFRLE1BQU0sT0FBT0EsUUFBUTtRQUNqQyxJQUFJQSxRQUFRLE9BQU8sTUFBTSxPQUFPLENBQUNBLFFBQVEsSUFBRyxFQUFHQyxPQUFPLENBQUMsS0FBSztRQUM1RCxPQUFPLENBQUNELFFBQVMsUUFBTyxJQUFHLENBQUMsRUFBR0MsT0FBTyxDQUFDLEtBQUs7SUFDOUM7SUF4Y0FDLGFBQWM7SUFDWixxQ0FBcUM7SUFDdkM7QUF1Y0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3V0aWxzL2RvY3VtZW50UHJvY2Vzc29yLnRzPzlkNWUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG1hbW1vdGggZnJvbSAnbWFtbW90aCc7XG5pbXBvcnQgeyBEb2N1bWVudCwgUGFja2VyLCBQYXJhZ3JhcGgsIFRleHRSdW4sIEhlYWRpbmdMZXZlbCwgQWxpZ25tZW50VHlwZSwgVGFibGUsIFRhYmxlUm93LCBUYWJsZUNlbGwsIFdpZHRoVHlwZSwgSW1hZ2VSdW4gfSBmcm9tICdkb2N4JztcbmltcG9ydCBKU1ppcCBmcm9tICdqc3ppcCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3R5bGVGb3JtYXR0aW5nIHtcbiAgYm9sZD86IGJvb2xlYW47XG4gIGl0YWxpYz86IGJvb2xlYW47XG4gIHVuZGVybGluZT86IGJvb2xlYW47XG4gIGZvbnRTaXplPzogbnVtYmVyO1xuICBjb2xvcj86IHN0cmluZztcbiAgYWxpZ25tZW50PzogJ2xlZnQnIHwgJ2NlbnRlcicgfCAncmlnaHQnIHwgJ2p1c3RpZnknO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN0eWxlIHtcbiAgaWQ6IHN0cmluZztcbiAgbmFtZTogc3RyaW5nO1xuICB3b3JkU3R5bGU6IHN0cmluZztcbiAgbWFya2VyOiBzdHJpbmc7XG4gIHByb21wdDogc3RyaW5nO1xuICBjb2xvcjogc3RyaW5nO1xuICBvcmRlcjogbnVtYmVyO1xuICBlbGVtZW50VHlwZTogJ3RleHQnIHwgJ2ltYWdlJyB8ICd0YWJsZSc7XG4gIGhhc1Jlc2lkdWU/OiBib29sZWFuO1xuICBhbGxvd0lubGluZUltYWdlcz86IGJvb2xlYW47XG4gIGZvcm1hdHRpbmc/OiBTdHlsZUZvcm1hdHRpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNpdGlvbiB7XG4gIGZyb206IG51bWJlcjtcbiAgdG86IG51bWJlcjtcbiAgdHlwZTogJ25vbmUnIHwgJ3JlcXVpcmVkJyB8ICdvcHRpb25hbCc7XG4gIGFsdGVybmF0aXZlczogbnVtYmVyW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVtb3ZhbFByb21wdCB7XG4gIGlkOiBzdHJpbmc7XG4gIG5hbWU6IHN0cmluZztcbiAgc3RhcnRNYXJrZXI6IHN0cmluZztcbiAgZW5kTWFya2VyOiBzdHJpbmc7XG4gIHByb21wdDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBvc3RQcm9jZXNzaW5nT3B0aW9ucyB7XG4gIHJlbW92ZVF1ZXN0aW9uTnVtYmVycz86IGJvb2xlYW47XG4gIHJlbW92ZUFsdGVybmF0aXZlTGV0dGVycz86IGJvb2xlYW47XG4gIGN1c3RvbVJlbW92YWxzPzogc3RyaW5nW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvY2Vzc2luZ1Jlc3VsdCB7XG4gIHN1Y2Nlc3M6IGJvb2xlYW47XG4gIGRvY3VtZW50QmxvYj86IEJsb2I7XG4gIHppcEJsb2I/OiBCbG9iO1xuICBzdGF0cz86IHtcbiAgICB0b3RhbFBhZ2VzOiBudW1iZXI7XG4gICAgdG90YWxQYXJhZ3JhcGhzOiBudW1iZXI7XG4gICAgcXVlc3Rpb25zUHJvY2Vzc2VkOiBudW1iZXI7XG4gICAgYXBpQ2FsbHM6IG51bWJlcjtcbiAgICBlc3RpbWF0ZWRDb3N0VVNEOiBudW1iZXI7XG4gIH07XG4gIGZpbGVzPzogQXJyYXk8e25hbWU6IHN0cmluZzsgc2l6ZTogc3RyaW5nOyBwYXRoOiBzdHJpbmd9PjtcbiAgZXJyb3I/OiBzdHJpbmc7XG4gIHByb2Nlc3NpbmdUaW1lPzogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgUHJvY2Vzc2VkUGFyYWdyYXBoIHtcbiAgdGV4dDogc3RyaW5nO1xuICBzdHlsZTogc3RyaW5nIHwgbnVsbDtcbiAgcmVtb3ZlOiBib29sZWFuO1xuICB0eXBlOiAndGV4dCcgfCAnaW1hZ2UnIHwgJ3RhYmxlJztcbiAgaW1hZ2VEYXRhPzogc3RyaW5nO1xuICB0YWJsZURhdGE/OiBhbnlbXVtdO1xufVxuXG5leHBvcnQgY2xhc3MgRG9jdW1lbnRQcm9jZXNzb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvLyBBUEkga2V5IGlzIG5vdyBoYW5kbGVkIHNlcnZlci1zaWRlXG4gIH1cblxuICBhc3luYyBwcm9jZXNzRG9jdW1lbnQoXG4gICAgZmlsZTogRmlsZSxcbiAgICBib29rTmFtZTogc3RyaW5nLFxuICAgIHN0eWxlczogU3R5bGVbXSxcbiAgICB0cmFuc2l0aW9uczogVHJhbnNpdGlvbltdLFxuICAgIHJlbW92YWxQcm9tcHRzOiBSZW1vdmFsUHJvbXB0W10sXG4gICAgcG9zdFByb2Nlc3Npbmc/OiBQb3N0UHJvY2Vzc2luZ09wdGlvbnMsXG4gICAgb25Qcm9ncmVzcz86IChwcm9ncmVzczogbnVtYmVyLCBtZXNzYWdlOiBzdHJpbmcpID0+IHZvaWRcbiAgKTogUHJvbWlzZTxQcm9jZXNzaW5nUmVzdWx0PiB7XG4gICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgb25Qcm9ncmVzcz8uKDUsICdMZW5kbyBkb2N1bWVudG8uLi4nKTtcbiAgICAgIFxuICAgICAgLy8gUmVhZCBkb2N1bWVudCBjb250ZW50XG4gICAgICBjb25zdCBhcnJheUJ1ZmZlciA9IGF3YWl0IGZpbGUuYXJyYXlCdWZmZXIoKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG1hbW1vdGguZXh0cmFjdFJhd1RleHQoeyBhcnJheUJ1ZmZlciB9KTtcbiAgICAgIGNvbnN0IHRleHQgPSByZXN1bHQudmFsdWU7XG4gICAgICBcbiAgICAgIC8vIEV4dHJhY3QgcGFyYWdyYXBoc1xuICAgICAgY29uc3QgcGFyYWdyYXBocyA9IHRleHQuc3BsaXQoJ1xcbicpLmZpbHRlcihwID0+IHAudHJpbSgpLmxlbmd0aCA+IDApO1xuICAgICAgXG4gICAgICBvblByb2dyZXNzPy4oMjAsICdBbmFsaXNhbmRvIGVzdHJ1dHVyYSBkbyBkb2N1bWVudG8uLi4nKTtcbiAgICAgIFxuICAgICAgLy8gT1BUSU1JWkVEIEJBVENIIFBST0NFU1NJTkcgLSBGaXggcmVkdW5kYW5jeSBpc3N1ZVxuICAgICAgY29uc3QgcHJvY2Vzc2VkUGFyYWdyYXBocyA9IGF3YWl0IHRoaXMucHJvY2Vzc1BhcmFncmFwaHNPcHRpbWl6ZWQoXG4gICAgICAgIHBhcmFncmFwaHMsXG4gICAgICAgIHN0eWxlcyxcbiAgICAgICAgcmVtb3ZhbFByb21wdHMsXG4gICAgICAgIG9uUHJvZ3Jlc3NcbiAgICAgICk7XG4gICAgICBcbiAgICAgIC8vIEFwcGx5IHBvc3QtcHJvY2Vzc2luZyBpZiByZXF1ZXN0ZWRcbiAgICAgIGlmIChwb3N0UHJvY2Vzc2luZykge1xuICAgICAgICBvblByb2dyZXNzPy4oNjUsICdBcGxpY2FuZG8gcMOzcy1wcm9jZXNzYW1lbnRvLi4uJyk7XG4gICAgICAgIHRoaXMuYXBwbHlQb3N0UHJvY2Vzc2luZyhwcm9jZXNzZWRQYXJhZ3JhcGhzLCBwb3N0UHJvY2Vzc2luZyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIG9uUHJvZ3Jlc3M/Lig3MCwgJ0FwbGljYW5kbyBlc3RpbG9zIGUgZm9ybWF0YcOnw6NvLi4uJyk7XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBzdHlsZWQgZG9jdW1lbnRcbiAgICAgIGNvbnN0IGRvYyA9IHRoaXMuY3JlYXRlU3R5bGVkRG9jdW1lbnQocHJvY2Vzc2VkUGFyYWdyYXBocywgc3R5bGVzLCBib29rTmFtZSk7XG4gICAgICBcbiAgICAgIG9uUHJvZ3Jlc3M/Lig4NSwgJ0NyaWFuZG8gYXJxdWl2byBzYW5pdGl6YWRvIHBhcmEgSW5EZXNpZ24uLi4nKTtcbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIHNhbml0aXplZCB2ZXJzaW9uIGZvciBJbkRlc2lnbiB3aXRoIGNvbnNpc3RlbnQgc3R5bGUgbmFtaW5nXG4gICAgICBjb25zdCBzYW5pdGl6ZWREb2MgPSB0aGlzLmNyZWF0ZVNhbml0aXplZERvY3VtZW50Rm9ySW5EZXNpZ24ocHJvY2Vzc2VkUGFyYWdyYXBocywgc3R5bGVzLCBib29rTmFtZSk7XG4gICAgICBcbiAgICAgIG9uUHJvZ3Jlc3M/Lig5MCwgJ0dlcmFuZG8gYXJxdWl2b3MgZmluYWlzLi4uJyk7XG4gICAgICBcbiAgICAgIC8vIEdlbmVyYXRlIGJsb2JzXG4gICAgICBjb25zdCBbbWFpbkJsb2IsIHNhbml0aXplZEJsb2JdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICBQYWNrZXIudG9CbG9iKGRvYyksXG4gICAgICAgIFBhY2tlci50b0Jsb2Ioc2FuaXRpemVkRG9jKVxuICAgICAgXSk7XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBaSVAgd2l0aCBhbGwgZmlsZXNcbiAgICAgIGNvbnN0IHppcCA9IG5ldyBKU1ppcCgpO1xuICAgICAgY29uc3QgdGltZXN0YW1wID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpLnJlcGxhY2UoL1s6Ll0vZywgJy0nKTtcbiAgICAgIGNvbnN0IGZvbGRlck5hbWUgPSBgJHtib29rTmFtZX1fJHt0aW1lc3RhbXB9YDtcbiAgICAgIFxuICAgICAgemlwLmZvbGRlcihmb2xkZXJOYW1lKT8uZmlsZSgnY29tcGxldG8uZG9jeCcsIG1haW5CbG9iKTtcbiAgICAgIHppcC5mb2xkZXIoZm9sZGVyTmFtZSk/LmZpbGUoJ2NvbXBsZXRvX3Byb250b19wYXJhX2luZGVzaWduLmRvY3gnLCBzYW5pdGl6ZWRCbG9iKTtcbiAgICAgIFxuICAgICAgY29uc3QgemlwQmxvYiA9IGF3YWl0IHppcC5nZW5lcmF0ZUFzeW5jKHsgdHlwZTogJ2Jsb2InIH0pO1xuICAgICAgXG4gICAgICBjb25zdCBwcm9jZXNzaW5nVGltZSA9IE1hdGgucm91bmQoKERhdGUubm93KCkgLSBzdGFydFRpbWUpIC8gMTAwMCk7XG4gICAgICBcbiAgICAgIG9uUHJvZ3Jlc3M/LigxMDAsICdQcm9jZXNzYW1lbnRvIGNvbmNsdcOtZG8hJyk7XG4gICAgICBcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIGRvY3VtZW50QmxvYjogbWFpbkJsb2IsXG4gICAgICAgIHppcEJsb2IsXG4gICAgICAgIHN0YXRzOiB7XG4gICAgICAgICAgdG90YWxQYWdlczogTWF0aC5jZWlsKHBhcmFncmFwaHMubGVuZ3RoIC8gMzApLFxuICAgICAgICAgIHRvdGFsUGFyYWdyYXBoczogcGFyYWdyYXBocy5sZW5ndGgsXG4gICAgICAgICAgcXVlc3Rpb25zUHJvY2Vzc2VkOiBwcm9jZXNzZWRQYXJhZ3JhcGhzLmZpbHRlcihwID0+IHAuc3R5bGUgPT09ICdlbnVuY2lhZG8nIHx8IHAuc3R5bGUgPT09ICdxdWVzdGFvJykubGVuZ3RoLFxuICAgICAgICAgIGFwaUNhbGxzOiBNYXRoLmNlaWwocGFyYWdyYXBocy5sZW5ndGggLyAyNSksIC8vIEJhbGFuY2VkIGJhdGNoIHNpemUgZm9yIGFjY3VyYWN5XG4gICAgICAgICAgZXN0aW1hdGVkQ29zdFVTRDogTWF0aC5jZWlsKHBhcmFncmFwaHMubGVuZ3RoIC8gMjUpICogMC4wMDJcbiAgICAgICAgfSxcbiAgICAgICAgZmlsZXM6IFtcbiAgICAgICAgICB7IG5hbWU6ICdjb21wbGV0by5kb2N4Jywgc2l6ZTogdGhpcy5mb3JtYXRGaWxlU2l6ZShtYWluQmxvYi5zaXplKSwgcGF0aDogJ2NvbXBsZXRvLmRvY3gnIH0sXG4gICAgICAgICAgeyBuYW1lOiAnY29tcGxldG9fcHJvbnRvX3BhcmFfaW5kZXNpZ24uZG9jeCcsIHNpemU6IHRoaXMuZm9ybWF0RmlsZVNpemUoc2FuaXRpemVkQmxvYi5zaXplKSwgcGF0aDogJ2NvbXBsZXRvX3Byb250b19wYXJhX2luZGVzaWduLmRvY3gnIH1cbiAgICAgICAgXSxcbiAgICAgICAgcHJvY2Vzc2luZ1RpbWU6IGAke01hdGguZmxvb3IocHJvY2Vzc2luZ1RpbWUgLyA2MCl9bSAke3Byb2Nlc3NpbmdUaW1lICUgNjB9c2BcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm8gbm8gcHJvY2Vzc2FtZW50bzonLCBlcnJvcik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ0Vycm8gZGVzY29uaGVjaWRvIG5vIHByb2Nlc3NhbWVudG8nXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgcHJvY2Vzc1BhcmFncmFwaHNPcHRpbWl6ZWQoXG4gICAgcGFyYWdyYXBoczogc3RyaW5nW10sXG4gICAgc3R5bGVzOiBTdHlsZVtdLFxuICAgIHJlbW92YWxQcm9tcHRzOiBSZW1vdmFsUHJvbXB0W10sXG4gICAgb25Qcm9ncmVzcz86IChwcm9ncmVzczogbnVtYmVyLCBtZXNzYWdlOiBzdHJpbmcpID0+IHZvaWRcbiAgKTogUHJvbWlzZTxQcm9jZXNzZWRQYXJhZ3JhcGhbXT4ge1xuICAgIGNvbnN0IHByb2Nlc3NlZFBhcmFncmFwaHM6IFByb2Nlc3NlZFBhcmFncmFwaFtdID0gW107XG4gICAgbGV0IGFwaUNhbGxzID0gMDtcbiAgICBcbiAgICAvLyBPUFRJTUlaRUQ6IEJhbGFuY2UgYmV0d2VlbiBjb250ZXh0IGFuZCBhY2N1cmFjeVxuICAgIC8vIDIwLTI1IHBhcmFncmFwaHMgZ2l2ZXMgZW5vdWdoIGNvbnRleHQgd2l0aG91dCBvdmVyd2hlbG1pbmcgdGhlIEFJXG4gICAgY29uc3QgYmF0Y2hTaXplID0gMjU7IC8vIE9wdGltYWwgZm9yIGFjY3VyYWN5IHdpdGggY29udGV4dFxuICAgIFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyYWdyYXBocy5sZW5ndGg7IGkgKz0gYmF0Y2hTaXplKSB7XG4gICAgICBjb25zdCBiYXRjaCA9IHBhcmFncmFwaHMuc2xpY2UoaSwgTWF0aC5taW4oaSArIGJhdGNoU2l6ZSwgcGFyYWdyYXBocy5sZW5ndGgpKTtcbiAgICAgIFxuICAgICAgLy8gQWRkIHNvbWUgY29udGV4dCBmcm9tIHByZXZpb3VzIGJhdGNoIGZvciBjb250aW51aXR5IChsYXN0IDMgcGFyYWdyYXBocylcbiAgICAgIGxldCBjb250ZXh0QmF0Y2ggPSBiYXRjaDtcbiAgICAgIGlmIChpID4gMCAmJiBwcm9jZXNzZWRQYXJhZ3JhcGhzLmxlbmd0aCA+PSAzKSB7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzQ29udGV4dCA9IHBhcmFncmFwaHMuc2xpY2UoTWF0aC5tYXgoMCwgaSAtIDMpLCBpKTtcbiAgICAgICAgY29udGV4dEJhdGNoID0gWy4uLnByZXZpb3VzQ29udGV4dCwgLi4uYmF0Y2hdO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBCdWlsZCBjb250ZXh0LWF3YXJlIHByb21wdFxuICAgICAgY29uc3QgcHJvbXB0ID0gdGhpcy5idWlsZE9wdGltaXplZFByb21wdChjb250ZXh0QmF0Y2gsIHN0eWxlcywgcmVtb3ZhbFByb21wdHMsIGksIHBhcmFncmFwaHMubGVuZ3RoLCBpID4gMCA/IDMgOiAwKTtcbiAgICAgIFxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLm9wZW5haS5jaGF0LmNvbXBsZXRpb25zLmNyZWF0ZSh7XG4gICAgICAgICAgbW9kZWw6ICdncHQtNG8tbWluaScsXG4gICAgICAgICAgbWVzc2FnZXM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcm9sZTogJ3N5c3RlbScsXG4gICAgICAgICAgICAgIGNvbnRlbnQ6IGBWb2PDqiDDqSB1bSBhc3Npc3RlbnRlIGVzcGVjaWFsaXphZG8gZW0gZm9ybWF0YXIgZG9jdW1lbnRvcyBlZHVjYWNpb25haXMuXG5BbmFsaXNlIG8gdGV4dG8gZSBtYXJxdWUgQ0FEQSBwYXLDoWdyYWZvIGNvbSB0YWdzIFhNTCBhcHJvcHJpYWRhcy5cbklNUE9SVEFOVEU6IFxuLSBNYXJxdWUgVE9ET1Mgb3MgcGFyw6FncmFmb3MsIG1lc21vIHF1ZSBuw6NvIGNvcnJlc3BvbmRhbSBhIG5lbmh1bSBlc3RpbG8gZXNwZWPDrWZpY28gKHVzZSA8bm9ybWFsPiBwYXJhIHRleHRvIGNvbXVtKVxuLSBNYW50ZW5oYSBhIG9yZGVtIGV4YXRhIGRvcyBwYXLDoWdyYWZvc1xuLSBQYXJhIHJlbW/Dp8O1ZXMsIHVzZSBhcyB0YWdzIGRlIGluw61jaW8gZSBmaW0gZXNwZWNpZmljYWRhc2BcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHJvbGU6ICd1c2VyJyxcbiAgICAgICAgICAgICAgY29udGVudDogcHJvbXB0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgXSxcbiAgICAgICAgICB0ZW1wZXJhdHVyZTogMC4yLFxuICAgICAgICAgIG1heF90b2tlbnM6IDgwMDBcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBhcGlDYWxscysrO1xuICAgICAgICBjb25zdCBtYXJrZWRDb250ZW50ID0gcmVzcG9uc2UuY2hvaWNlc1swXS5tZXNzYWdlLmNvbnRlbnQgfHwgJyc7XG4gICAgICAgIFxuICAgICAgICAvLyBQYXJzZSBtYXJrZWQgY29udGVudFxuICAgICAgICBjb25zdCBwYXJzZWQgPSB0aGlzLnBhcnNlTWFya2VkQ29udGVudChtYXJrZWRDb250ZW50LCBzdHlsZXMpO1xuICAgICAgICBwcm9jZXNzZWRQYXJhZ3JhcGhzLnB1c2goLi4ucGFyc2VkKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHByb2dyZXNzID0gMjAgKyAoKGkgKyBiYXRjaFNpemUpIC8gcGFyYWdyYXBocy5sZW5ndGgpICogNTA7XG4gICAgICAgIG9uUHJvZ3Jlc3M/LihNYXRoLm1pbihwcm9ncmVzcywgNzApLCBgUHJvY2Vzc2FuZG8gJHtNYXRoLm1pbihpICsgYmF0Y2hTaXplLCBwYXJhZ3JhcGhzLmxlbmd0aCl9LyR7cGFyYWdyYXBocy5sZW5ndGh9IHBhcsOhZ3JhZm9zLi4uYCk7XG4gICAgICAgIFxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJybyBhbyBwcm9jZXNzYXIgYmF0Y2g6JywgZXJyb3IpO1xuICAgICAgICAvLyBBZGQgdW5wcm9jZXNzZWQgcGFyYWdyYXBocyBhcyBub3JtYWwgdGV4dFxuICAgICAgICBiYXRjaC5mb3JFYWNoKHRleHQgPT4ge1xuICAgICAgICAgIHByb2Nlc3NlZFBhcmFncmFwaHMucHVzaCh7IHRleHQsIHN0eWxlOiAnbm9ybWFsJywgcmVtb3ZlOiBmYWxzZSwgdHlwZTogJ3RleHQnIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHByb2Nlc3NlZFBhcmFncmFwaHM7XG4gIH1cblxuICBwcml2YXRlIGJ1aWxkT3B0aW1pemVkUHJvbXB0KGJhdGNoOiBzdHJpbmdbXSwgc3R5bGVzOiBTdHlsZVtdLCByZW1vdmFsUHJvbXB0czogUmVtb3ZhbFByb21wdFtdLCBzdGFydEluZGV4OiBudW1iZXIsIHRvdGFsUGFyYWdyYXBoczogbnVtYmVyLCBjb250ZXh0T2Zmc2V0OiBudW1iZXIgPSAwKTogc3RyaW5nIHtcbiAgICBjb25zdCBhY3R1YWxTdGFydCA9IHN0YXJ0SW5kZXggLSBjb250ZXh0T2Zmc2V0ICsgMTtcbiAgICBjb25zdCBhY3R1YWxFbmQgPSBNYXRoLm1pbihzdGFydEluZGV4ICsgYmF0Y2gubGVuZ3RoIC0gY29udGV4dE9mZnNldCwgdG90YWxQYXJhZ3JhcGhzKTtcbiAgICBsZXQgcHJvbXB0ID0gYENvbnRleHRvOiBBbmFsaXNhbmRvIHBhcsOhZ3JhZm9zICR7YWN0dWFsU3RhcnR9IGEgJHthY3R1YWxFbmR9IGRlIHVtIHRvdGFsIGRlICR7dG90YWxQYXJhZ3JhcGhzfS5cXG5gO1xuICAgIGlmIChjb250ZXh0T2Zmc2V0ID4gMCkge1xuICAgICAgcHJvbXB0ICs9IGBOb3RhOiBPcyBwcmltZWlyb3MgJHtjb250ZXh0T2Zmc2V0fSBwYXLDoWdyYWZvcyBzw6NvIGNvbnRleHRvIGRhIGJhdGNoIGFudGVyaW9yIChqw6EgcHJvY2Vzc2Fkb3MpLlxcbmA7XG4gICAgfVxuICAgIHByb21wdCArPSAnXFxuJztcbiAgICBcbiAgICBwcm9tcHQgKz0gYEVTVElMT1MgRElTUE9Ow41WRUlTOlxcbmA7XG4gICAgc3R5bGVzLmZvckVhY2goc3R5bGUgPT4ge1xuICAgICAgaWYgKHN0eWxlLmVsZW1lbnRUeXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgcHJvbXB0ICs9IGA8JHtzdHlsZS5tYXJrZXIucmVwbGFjZSgvW1xcW1xcXV0vZywgJycpfT4gLSAke3N0eWxlLnByb21wdH1cXG5gO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIHByb21wdCArPSBgXFxuUkVNT8OHw5VFUzpcXG5gO1xuICAgIHJlbW92YWxQcm9tcHRzLmZvckVhY2gocmVtb3ZhbCA9PiB7XG4gICAgICBwcm9tcHQgKz0gYCR7cmVtb3ZhbC5zdGFydE1hcmtlcn0gZSAke3JlbW92YWwuZW5kTWFya2VyfSAtICR7cmVtb3ZhbC5wcm9tcHR9XFxuYDtcbiAgICB9KTtcbiAgICBcbiAgICBwcm9tcHQgKz0gYFxcblRFWFRPIFBBUkEgQU5BTElTQVI6XFxuYDtcbiAgICBiYXRjaC5mb3JFYWNoKChwYXJhLCBpbmRleCkgPT4ge1xuICAgICAgcHJvbXB0ICs9IGBbUCR7c3RhcnRJbmRleCArIGluZGV4ICsgMX1dICR7cGFyYX1cXG5gO1xuICAgIH0pO1xuICAgIFxuICAgIHByb21wdCArPSBgXFxuUkVUT1JORSBvIHRleHRvIG1hcmNhZG8gbWFudGVuZG8gYSBudW1lcmHDp8OjbyBbUCNdIGUgYXBsaWNhbmRvIGFzIHRhZ3MgYXByb3ByaWFkYXMuXG5FeGVtcGxvIGRlIHNhw61kYTpcbltQMV0gPFRJVFVMT19TSU1VTEFETz5TaW11bGFkbyAxPC9USVRVTE9fU0lNVUxBRE8+XG5bUDJdIDxub3JtYWw+VGV4dG8gY29tdW0gc2VtIGVzdGlsbyBlc3BlY8OtZmljbzwvbm9ybWFsPlxuW1AzXSA8RU5VTkNJQURPPjEuIFF1YWwgw6kgYSBjYXBpdGFsIGRvIEJyYXNpbD88L0VOVU5DSUFETz5cbltQNF0gPEFMVEVSTkFUSVZBPmEpIFPDo28gUGF1bG88L0FMVEVSTkFUSVZBPmA7XG4gICAgXG4gICAgcmV0dXJuIHByb21wdDtcbiAgfVxuXG4gIHByaXZhdGUgcGFyc2VNYXJrZWRDb250ZW50KGNvbnRlbnQ6IHN0cmluZywgc3R5bGVzOiBTdHlsZVtdKTogUHJvY2Vzc2VkUGFyYWdyYXBoW10ge1xuICAgIGNvbnN0IHBhcnNlZDogUHJvY2Vzc2VkUGFyYWdyYXBoW10gPSBbXTtcbiAgICBjb25zdCBsaW5lcyA9IGNvbnRlbnQuc3BsaXQoJ1xcbicpO1xuICAgIFxuICAgIGZvciAoY29uc3QgbGluZSBvZiBsaW5lcykge1xuICAgICAgaWYgKCFsaW5lLnRyaW0oKSkgY29udGludWU7XG4gICAgICBcbiAgICAgIC8vIEV4dHJhY3QgcGFyYWdyYXBoIG51bWJlciBpZiBwcmVzZW50XG4gICAgICBjb25zdCBwYXJhTWF0Y2ggPSBsaW5lLm1hdGNoKC9cXFtQXFxkK1xcXS8pO1xuICAgICAgY29uc3QgY2xlYW5MaW5lID0gcGFyYU1hdGNoID8gbGluZS5yZXBsYWNlKHBhcmFNYXRjaFswXSwgJycpLnRyaW0oKSA6IGxpbmUudHJpbSgpO1xuICAgICAgXG4gICAgICBsZXQgbWF0Y2hlZCA9IGZhbHNlO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBmb3IgcmVtb3ZhbCBtYXJrZXJzXG4gICAgICBpZiAoY2xlYW5MaW5lLmluY2x1ZGVzKCdSRU1PVkUnKSAmJiAoY2xlYW5MaW5lLmluY2x1ZGVzKCdTVEFSVCcpIHx8IGNsZWFuTGluZS5pbmNsdWRlcygnRU5EJykpKSB7XG4gICAgICAgIHBhcnNlZC5wdXNoKHsgXG4gICAgICAgICAgdGV4dDogdGhpcy5leHRyYWN0VGV4dChjbGVhbkxpbmUpLCBcbiAgICAgICAgICBzdHlsZTogbnVsbCwgXG4gICAgICAgICAgcmVtb3ZlOiB0cnVlLCBcbiAgICAgICAgICB0eXBlOiAndGV4dCcgXG4gICAgICAgIH0pO1xuICAgICAgICBtYXRjaGVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENoZWNrIGZvciBzdHlsZSBtYXJrZXJzXG4gICAgICAgIGZvciAoY29uc3Qgc3R5bGUgb2Ygc3R5bGVzKSB7XG4gICAgICAgICAgY29uc3QgbWFya2VyID0gc3R5bGUubWFya2VyLnJlcGxhY2UoL1tcXFtcXF1dL2csICcnKTtcbiAgICAgICAgICBjb25zdCB0YWdSZWdleCA9IG5ldyBSZWdFeHAoYDwke21hcmtlcn0+KC4qPyk8LyR7bWFya2VyfT5gLCAnaScpO1xuICAgICAgICAgIGNvbnN0IG1hdGNoID0gY2xlYW5MaW5lLm1hdGNoKHRhZ1JlZ2V4KTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIHBhcnNlZC5wdXNoKHsgXG4gICAgICAgICAgICAgIHRleHQ6IG1hdGNoWzFdLnRyaW0oKSwgXG4gICAgICAgICAgICAgIHN0eWxlOiBzdHlsZS5pZCwgXG4gICAgICAgICAgICAgIHJlbW92ZTogZmFsc2UsIFxuICAgICAgICAgICAgICB0eXBlOiBzdHlsZS5lbGVtZW50VHlwZSBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbWF0Y2hlZCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gSWYgbm8gbWF0Y2gsIGNoZWNrIGZvciBub3JtYWwgdGFnIG9yIGFkZCBhcyBub3JtYWwgdGV4dFxuICAgICAgaWYgKCFtYXRjaGVkKSB7XG4gICAgICAgIGNvbnN0IG5vcm1hbE1hdGNoID0gY2xlYW5MaW5lLm1hdGNoKC88bm9ybWFsPiguKj8pPFxcL25vcm1hbD4vaSk7XG4gICAgICAgIGlmIChub3JtYWxNYXRjaCkge1xuICAgICAgICAgIHBhcnNlZC5wdXNoKHsgXG4gICAgICAgICAgICB0ZXh0OiBub3JtYWxNYXRjaFsxXS50cmltKCksIFxuICAgICAgICAgICAgc3R5bGU6ICdub3JtYWwnLCBcbiAgICAgICAgICAgIHJlbW92ZTogZmFsc2UsIFxuICAgICAgICAgICAgdHlwZTogJ3RleHQnIFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGNsZWFuVGV4dCA9IHRoaXMuZXh0cmFjdFRleHQoY2xlYW5MaW5lKTtcbiAgICAgICAgICBpZiAoY2xlYW5UZXh0KSB7XG4gICAgICAgICAgICBwYXJzZWQucHVzaCh7IFxuICAgICAgICAgICAgICB0ZXh0OiBjbGVhblRleHQsIFxuICAgICAgICAgICAgICBzdHlsZTogJ25vcm1hbCcsIFxuICAgICAgICAgICAgICByZW1vdmU6IGZhbHNlLCBcbiAgICAgICAgICAgICAgdHlwZTogJ3RleHQnIFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cblxuICBwcml2YXRlIGV4dHJhY3RUZXh0KGxpbmU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGxpbmUucmVwbGFjZSgvPFtePl0qPi9nLCAnJykucmVwbGFjZSgvXFxbUFxcZCtcXF0vLCAnJykudHJpbSgpO1xuICB9XG5cbiAgcHJpdmF0ZSBjcmVhdGVTdHlsZWREb2N1bWVudChwcm9jZXNzZWRQYXJhZ3JhcGhzOiBQcm9jZXNzZWRQYXJhZ3JhcGhbXSwgc3R5bGVzOiBTdHlsZVtdLCBib29rTmFtZTogc3RyaW5nKTogRG9jdW1lbnQge1xuICAgIGNvbnN0IGNoaWxkcmVuOiBQYXJhZ3JhcGhbXSA9IFtdO1xuICAgIFxuICAgIC8vIEFkZCB0aXRsZVxuICAgIGNoaWxkcmVuLnB1c2goXG4gICAgICBuZXcgUGFyYWdyYXBoKHtcbiAgICAgICAgYWxpZ25tZW50OiBBbGlnbm1lbnRUeXBlLkNFTlRFUixcbiAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICBuZXcgVGV4dFJ1bih7XG4gICAgICAgICAgICB0ZXh0OiBib29rTmFtZSxcbiAgICAgICAgICAgIGJvbGQ6IHRydWUsXG4gICAgICAgICAgICBzaXplOiAzMixcbiAgICAgICAgICAgIGNvbG9yOiAnMWU0MGFmJ1xuICAgICAgICAgIH0pXG4gICAgICAgIF0sXG4gICAgICAgIHNwYWNpbmc6IHsgYWZ0ZXI6IDQwMCB9XG4gICAgICB9KVxuICAgICk7XG4gICAgXG4gICAgLy8gUHJvY2VzcyBwYXJhZ3JhcGhzXG4gICAgZm9yIChjb25zdCBwYXJhIG9mIHByb2Nlc3NlZFBhcmFncmFwaHMpIHtcbiAgICAgIGlmIChwYXJhLnJlbW92ZSkgY29udGludWU7XG4gICAgICBcbiAgICAgIGNvbnN0IHN0eWxlID0gc3R5bGVzLmZpbmQocyA9PiBzLmlkID09PSBwYXJhLnN0eWxlKTtcbiAgICAgIGNvbnN0IGZvcm1hdHRpbmcgPSBzdHlsZT8uZm9ybWF0dGluZyB8fCB7fTtcbiAgICAgIFxuICAgICAgbGV0IGFsaWdubWVudDogQWxpZ25tZW50VHlwZSA9IEFsaWdubWVudFR5cGUuTEVGVDtcbiAgICAgIGlmIChmb3JtYXR0aW5nLmFsaWdubWVudCA9PT0gJ2NlbnRlcicpIGFsaWdubWVudCA9IEFsaWdubWVudFR5cGUuQ0VOVEVSO1xuICAgICAgaWYgKGZvcm1hdHRpbmcuYWxpZ25tZW50ID09PSAncmlnaHQnKSBhbGlnbm1lbnQgPSBBbGlnbm1lbnRUeXBlLlJJR0hUO1xuICAgICAgaWYgKGZvcm1hdHRpbmcuYWxpZ25tZW50ID09PSAnanVzdGlmeScpIGFsaWdubWVudCA9IEFsaWdubWVudFR5cGUuSlVTVElGSUVEO1xuICAgICAgXG4gICAgICBjb25zdCBpc0hlYWRpbmcgPSBzdHlsZT8ud29yZFN0eWxlPy50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdoZWFkaW5nJyk7XG4gICAgICBcbiAgICAgIGNoaWxkcmVuLnB1c2goXG4gICAgICAgIG5ldyBQYXJhZ3JhcGgoe1xuICAgICAgICAgIGFsaWdubWVudCxcbiAgICAgICAgICBoZWFkaW5nOiBpc0hlYWRpbmcgPyBIZWFkaW5nTGV2ZWwuSEVBRElOR18yIDogdW5kZWZpbmVkLFxuICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICBuZXcgVGV4dFJ1bih7XG4gICAgICAgICAgICAgIHRleHQ6IHBhcmEudGV4dCxcbiAgICAgICAgICAgICAgYm9sZDogZm9ybWF0dGluZy5ib2xkIHx8IGZhbHNlLFxuICAgICAgICAgICAgICBpdGFsaWNzOiBmb3JtYXR0aW5nLml0YWxpYyB8fCBmYWxzZSxcbiAgICAgICAgICAgICAgdW5kZXJsaW5lOiBmb3JtYXR0aW5nLnVuZGVybGluZSA/IHt9IDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICBzaXplOiBmb3JtYXR0aW5nLmZvbnRTaXplID8gZm9ybWF0dGluZy5mb250U2l6ZSAqIDIgOiAyNCxcbiAgICAgICAgICAgICAgY29sb3I6IGZvcm1hdHRpbmcuY29sb3I/LnJlcGxhY2UoJyMnLCAnJykgfHwgJzAwMDAwMCdcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgXSxcbiAgICAgICAgICBzcGFjaW5nOiB7IGFmdGVyOiAyMDAgfVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIG5ldyBEb2N1bWVudCh7XG4gICAgICBzZWN0aW9uczogW3tcbiAgICAgICAgcHJvcGVydGllczoge30sXG4gICAgICAgIGNoaWxkcmVuXG4gICAgICB9XVxuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBhcHBseVBvc3RQcm9jZXNzaW5nKHBhcmFncmFwaHM6IFByb2Nlc3NlZFBhcmFncmFwaFtdLCBvcHRpb25zOiBQb3N0UHJvY2Vzc2luZ09wdGlvbnMpIHtcbiAgICBwYXJhZ3JhcGhzLmZvckVhY2gocGFyYSA9PiB7XG4gICAgICBpZiAocGFyYS5yZW1vdmUpIHJldHVybjtcbiAgICAgIFxuICAgICAgbGV0IHRleHQgPSBwYXJhLnRleHQ7XG4gICAgICBcbiAgICAgIC8vIFJlbW92ZSBxdWVzdGlvbiBudW1iZXJzIGlmIHJlcXVlc3RlZFxuICAgICAgaWYgKG9wdGlvbnMucmVtb3ZlUXVlc3Rpb25OdW1iZXJzICYmIChwYXJhLnN0eWxlID09PSAnZW51bmNpYWRvJyB8fCBwYXJhLnN0eWxlID09PSAncXVlc3RhbycpKSB7XG4gICAgICAgIC8vIFJlbW92ZSBwYXR0ZXJucyBsaWtlIFwiMS5cIiwgXCIxKVwiLCBcIjAxLlwiLCBcIlExOlwiLCBldGMuXG4gICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoL14oXFxkK1tcXC5cXCldXFxzKnxRXFxkKzo/XFxzKnxcXGQrXFxzKi1cXHMqKS9pLCAnJyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFJlbW92ZSBhbHRlcm5hdGl2ZSBsZXR0ZXJzIGlmIHJlcXVlc3RlZFxuICAgICAgaWYgKG9wdGlvbnMucmVtb3ZlQWx0ZXJuYXRpdmVMZXR0ZXJzICYmIHBhcmEuc3R5bGUgPT09ICdhbHRlcm5hdGl2YScpIHtcbiAgICAgICAgLy8gUmVtb3ZlIHBhdHRlcm5zIGxpa2UgXCJhKVwiLCBcIkEuXCIsIFwiKGEpXCIsIFwiW0FdXCIsIGV0Yy5cbiAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvXihcXCg/W2EtZUEtRV1bXFwuXFwpXVxcKT98XFxbW2EtZUEtRV1cXF0pXFxzKi9pLCAnJyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEFwcGx5IGN1c3RvbSByZW1vdmFsc1xuICAgICAgaWYgKG9wdGlvbnMuY3VzdG9tUmVtb3ZhbHMgJiYgb3B0aW9ucy5jdXN0b21SZW1vdmFscy5sZW5ndGggPiAwKSB7XG4gICAgICAgIG9wdGlvbnMuY3VzdG9tUmVtb3ZhbHMuZm9yRWFjaChwYXR0ZXJuID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKHBhdHRlcm4sICdnaScpO1xuICAgICAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZShyZWdleCwgJycpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIElmIHJlZ2V4IGlzIGludmFsaWQsIHRyeSBsaXRlcmFsIHJlcGxhY2VtZW50XG4gICAgICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKG5ldyBSZWdFeHAocGF0dGVybi5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgJ1xcXFwkJicpLCAnZ2knKSwgJycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHBhcmEudGV4dCA9IHRleHQudHJpbSgpO1xuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBjcmVhdGVTYW5pdGl6ZWREb2N1bWVudEZvckluRGVzaWduKHByb2Nlc3NlZFBhcmFncmFwaHM6IFByb2Nlc3NlZFBhcmFncmFwaFtdLCBzdHlsZXM6IFN0eWxlW10sIGJvb2tOYW1lOiBzdHJpbmcpOiBEb2N1bWVudCB7XG4gICAgY29uc3QgY2hpbGRyZW46IFBhcmFncmFwaFtdID0gW107XG4gICAgXG4gICAgLy8gQ3JlYXRlIGEgc3R5bGUgbWFwIHRvIGVuc3VyZSBjb25zaXN0ZW50IG5hbWluZyBmb3IgSW5EZXNpZ25cbiAgICBjb25zdCBzdHlsZU1hcCA9IG5ldyBNYXA8c3RyaW5nLCBzdHJpbmc+KCk7XG4gICAgc3R5bGVzLmZvckVhY2goc3R5bGUgPT4ge1xuICAgICAgLy8gVXNlIHRoZSBXb3JkIHN0eWxlIG5hbWUgZm9yIEluRGVzaWduIGNvbnNpc3RlbmN5XG4gICAgICAvLyBUaGlzIHByZXZlbnRzIGR1cGxpY2F0ZSBzdHlsZXMgd2l0aCBzYW1lIG5hbWVzXG4gICAgICBzdHlsZU1hcC5zZXQoc3R5bGUuaWQsIHN0eWxlLndvcmRTdHlsZSk7XG4gICAgfSk7XG4gICAgXG4gICAgLy8gQWRkIGRvY3VtZW50IGhlYWRlciB3aXRoIHN0eWxlIGRlZmluaXRpb25zIGZvciBJbkRlc2lnblxuICAgIGNoaWxkcmVuLnB1c2goXG4gICAgICBuZXcgUGFyYWdyYXBoKHtcbiAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICBuZXcgVGV4dFJ1bih7XG4gICAgICAgICAgICB0ZXh0OiBgW0lOREVTSUdOX1NUWUxFU19TVEFSVF1gLFxuICAgICAgICAgICAgc2l6ZTogMjBcbiAgICAgICAgICB9KVxuICAgICAgICBdXG4gICAgICB9KVxuICAgICk7XG4gICAgXG4gICAgLy8gTGlzdCBhbGwgc3R5bGVzIGZvciBJbkRlc2lnbiB0byByZWNvZ25pemVcbiAgICBzdHlsZXMuZm9yRWFjaChzdHlsZSA9PiB7XG4gICAgICBjaGlsZHJlbi5wdXNoKFxuICAgICAgICBuZXcgUGFyYWdyYXBoKHtcbiAgICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgICAgbmV3IFRleHRSdW4oe1xuICAgICAgICAgICAgICB0ZXh0OiBgW1NUWUxFX0RFRl0gJHtzdHlsZS53b3JkU3R5bGV9ID0gJHtzdHlsZS5tYXJrZXJ9YCxcbiAgICAgICAgICAgICAgc2l6ZTogMjBcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgXVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9KTtcbiAgICBcbiAgICBjaGlsZHJlbi5wdXNoKFxuICAgICAgbmV3IFBhcmFncmFwaCh7XG4gICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgbmV3IFRleHRSdW4oe1xuICAgICAgICAgICAgdGV4dDogYFtJTkRFU0lHTl9TVFlMRVNfRU5EXWAsXG4gICAgICAgICAgICBzaXplOiAyMFxuICAgICAgICAgIH0pXG4gICAgICAgIF0sXG4gICAgICAgIHNwYWNpbmc6IHsgYWZ0ZXI6IDQwMCB9XG4gICAgICB9KVxuICAgICk7XG4gICAgXG4gICAgLy8gUHJvY2VzcyBwYXJhZ3JhcGhzIHdpdGggY29uc2lzdGVudCBzdHlsZSBuYW1pbmdcbiAgICBmb3IgKGNvbnN0IHBhcmEgb2YgcHJvY2Vzc2VkUGFyYWdyYXBocykge1xuICAgICAgaWYgKHBhcmEucmVtb3ZlKSBjb250aW51ZTtcbiAgICAgIFxuICAgICAgY29uc3Qgc3R5bGUgPSBzdHlsZXMuZmluZChzID0+IHMuaWQgPT09IHBhcmEuc3R5bGUpO1xuICAgICAgY29uc3Qgc3R5bGVOYW1lID0gc3R5bGVNYXAuZ2V0KHBhcmEuc3R5bGUgfHwgJycpIHx8ICdOb3JtYWwnO1xuICAgICAgXG4gICAgICAvLyBVc2UgY29uc2lzdGVudCBzdHlsZSBuYW1pbmcgZm9yIEluRGVzaWduXG4gICAgICBjaGlsZHJlbi5wdXNoKFxuICAgICAgICBuZXcgUGFyYWdyYXBoKHtcbiAgICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgICAgbmV3IFRleHRSdW4oe1xuICAgICAgICAgICAgICB0ZXh0OiBgWyR7c3R5bGVOYW1lfV0gJHtwYXJhLnRleHR9YCxcbiAgICAgICAgICAgICAgc2l6ZTogMjRcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgXSxcbiAgICAgICAgICBzcGFjaW5nOiB7IGFmdGVyOiAxMjAgfVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIG5ldyBEb2N1bWVudCh7XG4gICAgICBzZWN0aW9uczogW3tcbiAgICAgICAgcHJvcGVydGllczoge30sXG4gICAgICAgIGNoaWxkcmVuXG4gICAgICB9XVxuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBmb3JtYXRGaWxlU2l6ZShieXRlczogbnVtYmVyKTogc3RyaW5nIHtcbiAgICBpZiAoYnl0ZXMgPCAxMDI0KSByZXR1cm4gYnl0ZXMgKyAnIEInO1xuICAgIGlmIChieXRlcyA8IDEwMjQgKiAxMDI0KSByZXR1cm4gKGJ5dGVzIC8gMTAyNCkudG9GaXhlZCgxKSArICcgS0InO1xuICAgIHJldHVybiAoYnl0ZXMgLyAoMTAyNCAqIDEwMjQpKS50b0ZpeGVkKDEpICsgJyBNQic7XG4gIH1cbn0iXSwibmFtZXMiOlsibWFtbW90aCIsIkRvY3VtZW50IiwiUGFja2VyIiwiUGFyYWdyYXBoIiwiVGV4dFJ1biIsIkhlYWRpbmdMZXZlbCIsIkFsaWdubWVudFR5cGUiLCJKU1ppcCIsIkRvY3VtZW50UHJvY2Vzc29yIiwicHJvY2Vzc0RvY3VtZW50IiwiZmlsZSIsImJvb2tOYW1lIiwic3R5bGVzIiwidHJhbnNpdGlvbnMiLCJyZW1vdmFsUHJvbXB0cyIsInBvc3RQcm9jZXNzaW5nIiwib25Qcm9ncmVzcyIsInN0YXJ0VGltZSIsIkRhdGUiLCJub3ciLCJ6aXAiLCJhcnJheUJ1ZmZlciIsInJlc3VsdCIsImV4dHJhY3RSYXdUZXh0IiwidGV4dCIsInZhbHVlIiwicGFyYWdyYXBocyIsInNwbGl0IiwiZmlsdGVyIiwicCIsInRyaW0iLCJsZW5ndGgiLCJwcm9jZXNzZWRQYXJhZ3JhcGhzIiwicHJvY2Vzc1BhcmFncmFwaHNPcHRpbWl6ZWQiLCJhcHBseVBvc3RQcm9jZXNzaW5nIiwiZG9jIiwiY3JlYXRlU3R5bGVkRG9jdW1lbnQiLCJzYW5pdGl6ZWREb2MiLCJjcmVhdGVTYW5pdGl6ZWREb2N1bWVudEZvckluRGVzaWduIiwibWFpbkJsb2IiLCJzYW5pdGl6ZWRCbG9iIiwiUHJvbWlzZSIsImFsbCIsInRvQmxvYiIsInRpbWVzdGFtcCIsInRvSVNPU3RyaW5nIiwicmVwbGFjZSIsImZvbGRlck5hbWUiLCJmb2xkZXIiLCJ6aXBCbG9iIiwiZ2VuZXJhdGVBc3luYyIsInR5cGUiLCJwcm9jZXNzaW5nVGltZSIsIk1hdGgiLCJyb3VuZCIsInN1Y2Nlc3MiLCJkb2N1bWVudEJsb2IiLCJzdGF0cyIsInRvdGFsUGFnZXMiLCJjZWlsIiwidG90YWxQYXJhZ3JhcGhzIiwicXVlc3Rpb25zUHJvY2Vzc2VkIiwic3R5bGUiLCJhcGlDYWxscyIsImVzdGltYXRlZENvc3RVU0QiLCJmaWxlcyIsIm5hbWUiLCJzaXplIiwiZm9ybWF0RmlsZVNpemUiLCJwYXRoIiwiZmxvb3IiLCJlcnJvciIsImNvbnNvbGUiLCJFcnJvciIsIm1lc3NhZ2UiLCJiYXRjaFNpemUiLCJpIiwiYmF0Y2giLCJzbGljZSIsIm1pbiIsImNvbnRleHRCYXRjaCIsInByZXZpb3VzQ29udGV4dCIsIm1heCIsInByb21wdCIsImJ1aWxkT3B0aW1pemVkUHJvbXB0IiwicmVzcG9uc2UiLCJvcGVuYWkiLCJjaGF0IiwiY29tcGxldGlvbnMiLCJjcmVhdGUiLCJtb2RlbCIsIm1lc3NhZ2VzIiwicm9sZSIsImNvbnRlbnQiLCJ0ZW1wZXJhdHVyZSIsIm1heF90b2tlbnMiLCJtYXJrZWRDb250ZW50IiwiY2hvaWNlcyIsInBhcnNlZCIsInBhcnNlTWFya2VkQ29udGVudCIsInB1c2giLCJwcm9ncmVzcyIsImZvckVhY2giLCJyZW1vdmUiLCJzdGFydEluZGV4IiwiY29udGV4dE9mZnNldCIsImFjdHVhbFN0YXJ0IiwiYWN0dWFsRW5kIiwiZWxlbWVudFR5cGUiLCJtYXJrZXIiLCJyZW1vdmFsIiwic3RhcnRNYXJrZXIiLCJlbmRNYXJrZXIiLCJwYXJhIiwiaW5kZXgiLCJsaW5lcyIsImxpbmUiLCJwYXJhTWF0Y2giLCJtYXRjaCIsImNsZWFuTGluZSIsIm1hdGNoZWQiLCJpbmNsdWRlcyIsImV4dHJhY3RUZXh0IiwidGFnUmVnZXgiLCJSZWdFeHAiLCJpZCIsIm5vcm1hbE1hdGNoIiwiY2xlYW5UZXh0IiwiY2hpbGRyZW4iLCJhbGlnbm1lbnQiLCJDRU5URVIiLCJib2xkIiwiY29sb3IiLCJzcGFjaW5nIiwiYWZ0ZXIiLCJmb3JtYXR0aW5nIiwiZmluZCIsInMiLCJMRUZUIiwiUklHSFQiLCJKVVNUSUZJRUQiLCJpc0hlYWRpbmciLCJ3b3JkU3R5bGUiLCJ0b0xvd2VyQ2FzZSIsImhlYWRpbmciLCJIRUFESU5HXzIiLCJ1bmRlZmluZWQiLCJpdGFsaWNzIiwiaXRhbGljIiwidW5kZXJsaW5lIiwiZm9udFNpemUiLCJzZWN0aW9ucyIsInByb3BlcnRpZXMiLCJvcHRpb25zIiwicmVtb3ZlUXVlc3Rpb25OdW1iZXJzIiwicmVtb3ZlQWx0ZXJuYXRpdmVMZXR0ZXJzIiwiY3VzdG9tUmVtb3ZhbHMiLCJwYXR0ZXJuIiwicmVnZXgiLCJlIiwic3R5bGVNYXAiLCJNYXAiLCJzZXQiLCJzdHlsZU5hbWUiLCJnZXQiLCJieXRlcyIsInRvRml4ZWQiLCJjb25zdHJ1Y3RvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/documentProcessor.ts\n"));

/***/ })

});